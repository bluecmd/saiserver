/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "switch_sai_rpc.h"

namespace switch_sai {


switch_sai_rpc_sai_thrift_set_port_attribute_args::~switch_sai_rpc_sai_thrift_set_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_pargs::~switch_sai_rpc_sai_thrift_set_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_result::~switch_sai_rpc_sai_thrift_set_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_port_attribute_presult::~switch_sai_rpc_sai_thrift_set_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_args::~switch_sai_rpc_sai_thrift_get_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_result::~switch_sai_rpc_sai_thrift_get_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_args::~switch_sai_rpc_sai_thrift_get_port_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->counter_ids.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += iprot->readI32(this->counter_ids[_i90]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter91;
    for (_iter91 = this->counter_ids.begin(); _iter91 != this->counter_ids.end(); ++_iter91)
    {
      xfer += oprot->writeI32((*_iter91));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_pargs::~switch_sai_rpc_sai_thrift_get_port_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_port_stat_counter_t> ::const_iterator _iter92;
    for (_iter92 = (*(this->counter_ids)).begin(); _iter92 != (*(this->counter_ids)).end(); ++_iter92)
    {
      xfer += oprot->writeI32((*_iter92));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_result::~switch_sai_rpc_sai_thrift_get_port_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->success.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readI64(this->success[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter98;
      for (_iter98 = this->success.begin(); _iter98 != this->success.end(); ++_iter98)
      {
        xfer += oprot->writeI64((*_iter98));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_stats_presult::~switch_sai_rpc_sai_thrift_get_port_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            (*(this->success)).resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += iprot->readI64((*(this->success))[_i103]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_args::~switch_sai_rpc_sai_thrift_clear_port_all_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_args");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs::~switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs");

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_result::~switch_sai_rpc_sai_thrift_clear_port_all_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_port_all_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_port_all_stats_presult::~switch_sai_rpc_sai_thrift_clear_port_all_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_port_all_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_args::~switch_sai_rpc_sai_thrift_create_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->thrift_attr_list.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->thrift_attr_list[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter109;
    for (_iter109 = this->thrift_attr_list.begin(); _iter109 != this->thrift_attr_list.end(); ++_iter109)
    {
      xfer += (*_iter109).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_create_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter110;
    for (_iter110 = (*(this->thrift_attr_list)).begin(); _iter110 != (*(this->thrift_attr_list)).end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_result::~switch_sai_rpc_sai_thrift_create_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_fdb_entry_presult::~switch_sai_rpc_sai_thrift_create_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_args::~switch_sai_rpc_sai_thrift_delete_fdb_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_fdb_entry.read(iprot);
          this->__isset.thrift_fdb_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_args");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_fdb_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs::~switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_fdb_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_fdb_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_result::~switch_sai_rpc_sai_thrift_delete_fdb_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_delete_fdb_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_delete_fdb_entry_presult::~switch_sai_rpc_sai_thrift_delete_fdb_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_delete_fdb_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_args::~switch_sai_rpc_sai_thrift_flush_fdb_entries_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->thrift_attr_list.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->thrift_attr_list[_i115].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter116;
    for (_iter116 = this->thrift_attr_list.begin(); _iter116 != this->thrift_attr_list.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs::~switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter117;
    for (_iter117 = (*(this->thrift_attr_list)).begin(); _iter117 != (*(this->thrift_attr_list)).end(); ++_iter117)
    {
      xfer += (*_iter117).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_result::~switch_sai_rpc_sai_thrift_flush_fdb_entries_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_flush_fdb_entries_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_flush_fdb_entries_presult::~switch_sai_rpc_sai_thrift_flush_fdb_entries_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_flush_fdb_entries_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entries_args::~switch_sai_rpc_sai_thrift_get_fdb_entries_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entries_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entries_pargs::~switch_sai_rpc_sai_thrift_get_fdb_entries_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entries_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entries_result::~switch_sai_rpc_sai_thrift_get_fdb_entries_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_fdb_entries_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_fdb_entries_presult::~switch_sai_rpc_sai_thrift_get_fdb_entries_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_fdb_entries_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_args::~switch_sai_rpc_sai_thrift_create_vlan_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->thrift_attr_list.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->thrift_attr_list[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter123;
    for (_iter123 = this->thrift_attr_list.begin(); _iter123 != this->thrift_attr_list.end(); ++_iter123)
    {
      xfer += (*_iter123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_pargs::~switch_sai_rpc_sai_thrift_create_vlan_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter124;
    for (_iter124 = (*(this->thrift_attr_list)).begin(); _iter124 != (*(this->thrift_attr_list)).end(); ++_iter124)
    {
      xfer += (*_iter124).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_result::~switch_sai_rpc_sai_thrift_create_vlan_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_presult::~switch_sai_rpc_sai_thrift_create_vlan_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_args::~switch_sai_rpc_sai_thrift_remove_vlan_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_oid);
          this->__isset.vlan_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_args");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_pargs::~switch_sai_rpc_sai_thrift_remove_vlan_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_pargs");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_result::~switch_sai_rpc_sai_thrift_remove_vlan_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_presult::~switch_sai_rpc_sai_thrift_remove_vlan_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_args::~switch_sai_rpc_sai_thrift_get_vlan_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->counter_ids.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readI32(this->counter_ids[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter130;
    for (_iter130 = this->counter_ids.begin(); _iter130 != this->counter_ids.end(); ++_iter130)
    {
      xfer += oprot->writeI32((*_iter130));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_pargs::~switch_sai_rpc_sai_thrift_get_vlan_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_vlan_stat_counter_t> ::const_iterator _iter131;
    for (_iter131 = (*(this->counter_ids)).begin(); _iter131 != (*(this->counter_ids)).end(); ++_iter131)
    {
      xfer += oprot->writeI32((*_iter131));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_result::~switch_sai_rpc_sai_thrift_get_vlan_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->success.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += iprot->readI64(this->success[_i136]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter137;
      for (_iter137 = this->success.begin(); _iter137 != this->success.end(); ++_iter137)
      {
        xfer += oprot->writeI64((*_iter137));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_stats_presult::~switch_sai_rpc_sai_thrift_get_vlan_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            (*(this->success)).resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += iprot->readI64((*(this->success))[_i142]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_args::~switch_sai_rpc_sai_thrift_create_vlan_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->thrift_attr_list.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += this->thrift_attr_list[_i147].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter148;
    for (_iter148 = this->thrift_attr_list.begin(); _iter148 != this->thrift_attr_list.end(); ++_iter148)
    {
      xfer += (*_iter148).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_pargs::~switch_sai_rpc_sai_thrift_create_vlan_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter149;
    for (_iter149 = (*(this->thrift_attr_list)).begin(); _iter149 != (*(this->thrift_attr_list)).end(); ++_iter149)
    {
      xfer += (*_iter149).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_result::~switch_sai_rpc_sai_thrift_create_vlan_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_vlan_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_vlan_member_presult::~switch_sai_rpc_sai_thrift_create_vlan_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_vlan_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_member_id);
          this->__isset.vlan_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_args::~switch_sai_rpc_sai_thrift_remove_vlan_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_member_id);
          this->__isset.vlan_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_args");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_pargs::~switch_sai_rpc_sai_thrift_remove_vlan_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_pargs");

  xfer += oprot->writeFieldBegin("vlan_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_result::~switch_sai_rpc_sai_thrift_remove_vlan_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_vlan_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_vlan_member_presult::~switch_sai_rpc_sai_thrift_remove_vlan_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_vlan_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_args::~switch_sai_rpc_sai_thrift_get_vlan_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs::~switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_result::~switch_sai_rpc_sai_thrift_get_vlan_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_attribute_presult::~switch_sai_rpc_sai_thrift_get_vlan_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_args::~switch_sai_rpc_sai_thrift_get_vlan_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_id);
          this->__isset.vlan_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_args");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_pargs::~switch_sai_rpc_sai_thrift_get_vlan_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_pargs");

  xfer += oprot->writeFieldBegin("vlan_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_result::~switch_sai_rpc_sai_thrift_get_vlan_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_vlan_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_vlan_id_presult::~switch_sai_rpc_sai_thrift_get_vlan_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_vlan_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_args::~switch_sai_rpc_sai_thrift_set_vlan_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vlan_oid);
          this->__isset.vlan_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_args");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vlan_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs::~switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs");

  xfer += oprot->writeFieldBegin("vlan_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vlan_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_result::~switch_sai_rpc_sai_thrift_set_vlan_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_vlan_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_vlan_attribute_presult::~switch_sai_rpc_sai_thrift_set_vlan_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_vlan_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_args::~switch_sai_rpc_sai_thrift_create_virtual_router_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->thrift_attr_list.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->thrift_attr_list[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter155;
    for (_iter155 = this->thrift_attr_list.begin(); _iter155 != this->thrift_attr_list.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_pargs::~switch_sai_rpc_sai_thrift_create_virtual_router_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter156;
    for (_iter156 = (*(this->thrift_attr_list)).begin(); _iter156 != (*(this->thrift_attr_list)).end(); ++_iter156)
    {
      xfer += (*_iter156).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_result::~switch_sai_rpc_sai_thrift_create_virtual_router_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_virtual_router_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_virtual_router_presult::~switch_sai_rpc_sai_thrift_create_virtual_router_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_virtual_router_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_args::~switch_sai_rpc_sai_thrift_remove_virtual_router_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vr_id);
          this->__isset.vr_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_args");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->vr_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_pargs::~switch_sai_rpc_sai_thrift_remove_virtual_router_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_pargs");

  xfer += oprot->writeFieldBegin("vr_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->vr_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_result::~switch_sai_rpc_sai_thrift_remove_virtual_router_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_virtual_router_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_virtual_router_presult::~switch_sai_rpc_sai_thrift_remove_virtual_router_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_virtual_router_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_args::~switch_sai_rpc_sai_thrift_create_route_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->thrift_attr_list.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += this->thrift_attr_list[_i161].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_route_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter162;
    for (_iter162 = this->thrift_attr_list.begin(); _iter162 != this->thrift_attr_list.end(); ++_iter162)
    {
      xfer += (*_iter162).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_pargs::~switch_sai_rpc_sai_thrift_create_route_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter163;
    for (_iter163 = (*(this->thrift_attr_list)).begin(); _iter163 != (*(this->thrift_attr_list)).end(); ++_iter163)
    {
      xfer += (*_iter163).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_result::~switch_sai_rpc_sai_thrift_create_route_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_route_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_route_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_route_presult::~switch_sai_rpc_sai_thrift_create_route_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_route_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_args::~switch_sai_rpc_sai_thrift_remove_route_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_route_entry.read(iprot);
          this->__isset.thrift_route_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_route_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_args");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_route_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_pargs::~switch_sai_rpc_sai_thrift_remove_route_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_pargs");

  xfer += oprot->writeFieldBegin("thrift_route_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_route_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_result::~switch_sai_rpc_sai_thrift_remove_route_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_route_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_route_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_route_presult::~switch_sai_rpc_sai_thrift_remove_route_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_route_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_args::~switch_sai_rpc_sai_thrift_create_router_interface_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _etype167;
            xfer += iprot->readListBegin(_etype167, _size164);
            this->thrift_attr_list.resize(_size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              xfer += this->thrift_attr_list[_i168].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_router_interface_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter169;
    for (_iter169 = this->thrift_attr_list.begin(); _iter169 != this->thrift_attr_list.end(); ++_iter169)
    {
      xfer += (*_iter169).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_pargs::~switch_sai_rpc_sai_thrift_create_router_interface_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter170;
    for (_iter170 = (*(this->thrift_attr_list)).begin(); _iter170 != (*(this->thrift_attr_list)).end(); ++_iter170)
    {
      xfer += (*_iter170).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_result::~switch_sai_rpc_sai_thrift_create_router_interface_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_router_interface_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_router_interface_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_router_interface_presult::~switch_sai_rpc_sai_thrift_create_router_interface_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_router_interface_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_args::~switch_sai_rpc_sai_thrift_remove_router_interface_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_pargs::~switch_sai_rpc_sai_thrift_remove_router_interface_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_result::~switch_sai_rpc_sai_thrift_remove_router_interface_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_router_interface_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_router_interface_presult::~switch_sai_rpc_sai_thrift_remove_router_interface_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_router_interface_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rif_id);
          this->__isset.rif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_args");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->rif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs");

  xfer += oprot->writeFieldBegin("rif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->rif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_router_interface_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult::~switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_args::~switch_sai_rpc_sai_thrift_create_next_hop_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->thrift_attr_list.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += this->thrift_attr_list[_i175].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter176;
    for (_iter176 = this->thrift_attr_list.begin(); _iter176 != this->thrift_attr_list.end(); ++_iter176)
    {
      xfer += (*_iter176).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter177;
    for (_iter177 = (*(this->thrift_attr_list)).begin(); _iter177 != (*(this->thrift_attr_list)).end(); ++_iter177)
    {
      xfer += (*_iter177).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_result::~switch_sai_rpc_sai_thrift_create_next_hop_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_presult::~switch_sai_rpc_sai_thrift_create_next_hop_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_args::~switch_sai_rpc_sai_thrift_remove_next_hop_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->next_hop_id);
          this->__isset.next_hop_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_args");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->next_hop_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_pargs");

  xfer += oprot->writeFieldBegin("next_hop_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->next_hop_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_result::~switch_sai_rpc_sai_thrift_remove_next_hop_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_args::~switch_sai_rpc_sai_thrift_create_next_hop_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->thrift_attr_list.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += this->thrift_attr_list[_i182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter183;
    for (_iter183 = this->thrift_attr_list.begin(); _iter183 != this->thrift_attr_list.end(); ++_iter183)
    {
      xfer += (*_iter183).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter184;
    for (_iter184 = (*(this->thrift_attr_list)).begin(); _iter184 != (*(this->thrift_attr_list)).end(); ++_iter184)
    {
      xfer += (*_iter184).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_result::~switch_sai_rpc_sai_thrift_create_next_hop_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_presult::~switch_sai_rpc_sai_thrift_create_next_hop_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_args::~switch_sai_rpc_sai_thrift_remove_next_hop_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_oid);
          this->__isset.nhop_group_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_args");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_result::~switch_sai_rpc_sai_thrift_remove_next_hop_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->thrift_attr_list.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += this->thrift_attr_list[_i189].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter190;
    for (_iter190 = this->thrift_attr_list.begin(); _iter190 != this->thrift_attr_list.end(); ++_iter190)
    {
      xfer += (*_iter190).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter191;
    for (_iter191 = (*(this->thrift_attr_list)).begin(); _iter191 != (*(this->thrift_attr_list)).end(); ++_iter191)
    {
      xfer += (*_iter191).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_next_hop_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult::~switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nhop_group_member_oid);
          this->__isset.nhop_group_member_oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->nhop_group_member_oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs");

  xfer += oprot->writeFieldBegin("nhop_group_member_oid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->nhop_group_member_oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult::~switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_args::~switch_sai_rpc_sai_thrift_create_lag_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _etype195;
            xfer += iprot->readListBegin(_etype195, _size192);
            this->thrift_attr_list.resize(_size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              xfer += this->thrift_attr_list[_i196].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter197;
    for (_iter197 = this->thrift_attr_list.begin(); _iter197 != this->thrift_attr_list.end(); ++_iter197)
    {
      xfer += (*_iter197).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_pargs::~switch_sai_rpc_sai_thrift_create_lag_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter198;
    for (_iter198 = (*(this->thrift_attr_list)).begin(); _iter198 != (*(this->thrift_attr_list)).end(); ++_iter198)
    {
      xfer += (*_iter198).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_result::~switch_sai_rpc_sai_thrift_create_lag_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_presult::~switch_sai_rpc_sai_thrift_create_lag_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_args::~switch_sai_rpc_sai_thrift_remove_lag_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_id);
          this->__isset.lag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_args");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_pargs::~switch_sai_rpc_sai_thrift_remove_lag_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_pargs");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_result::~switch_sai_rpc_sai_thrift_remove_lag_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_presult::~switch_sai_rpc_sai_thrift_remove_lag_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_args::~switch_sai_rpc_sai_thrift_set_lag_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_id);
          this->__isset.lag_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_args");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_pargs::~switch_sai_rpc_sai_thrift_set_lag_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_result::~switch_sai_rpc_sai_thrift_set_lag_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_lag_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_lag_attribute_presult::~switch_sai_rpc_sai_thrift_set_lag_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_lag_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_args::~switch_sai_rpc_sai_thrift_create_lag_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _etype202;
            xfer += iprot->readListBegin(_etype202, _size199);
            this->thrift_attr_list.resize(_size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              xfer += this->thrift_attr_list[_i203].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter204;
    for (_iter204 = this->thrift_attr_list.begin(); _iter204 != this->thrift_attr_list.end(); ++_iter204)
    {
      xfer += (*_iter204).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_pargs::~switch_sai_rpc_sai_thrift_create_lag_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter205;
    for (_iter205 = (*(this->thrift_attr_list)).begin(); _iter205 != (*(this->thrift_attr_list)).end(); ++_iter205)
    {
      xfer += (*_iter205).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_result::~switch_sai_rpc_sai_thrift_create_lag_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_lag_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_lag_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_lag_member_presult::~switch_sai_rpc_sai_thrift_create_lag_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_lag_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_args::~switch_sai_rpc_sai_thrift_remove_lag_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_member_id);
          this->__isset.lag_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_args");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_pargs::~switch_sai_rpc_sai_thrift_remove_lag_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_pargs");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_result::~switch_sai_rpc_sai_thrift_remove_lag_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_lag_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_lag_member_presult::~switch_sai_rpc_sai_thrift_remove_lag_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_lag_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lag_member_id);
          this->__isset.lag_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_args");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->lag_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs");

  xfer += oprot->writeFieldBegin("lag_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->lag_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_lag_member_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult::~switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_args::~switch_sai_rpc_sai_thrift_create_stp_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size206;
            ::apache::thrift::protocol::TType _etype209;
            xfer += iprot->readListBegin(_etype209, _size206);
            this->thrift_attr_list.resize(_size206);
            uint32_t _i210;
            for (_i210 = 0; _i210 < _size206; ++_i210)
            {
              xfer += this->thrift_attr_list[_i210].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter211;
    for (_iter211 = this->thrift_attr_list.begin(); _iter211 != this->thrift_attr_list.end(); ++_iter211)
    {
      xfer += (*_iter211).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_pargs::~switch_sai_rpc_sai_thrift_create_stp_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter212;
    for (_iter212 = (*(this->thrift_attr_list)).begin(); _iter212 != (*(this->thrift_attr_list)).end(); ++_iter212)
    {
      xfer += (*_iter212).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_result::~switch_sai_rpc_sai_thrift_create_stp_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_stp_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_stp_entry_presult::~switch_sai_rpc_sai_thrift_create_stp_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_stp_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_args::~switch_sai_rpc_sai_thrift_remove_stp_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_pargs::~switch_sai_rpc_sai_thrift_remove_stp_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_result::~switch_sai_rpc_sai_thrift_remove_stp_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_stp_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_stp_entry_presult::~switch_sai_rpc_sai_thrift_remove_stp_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_stp_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_args::~switch_sai_rpc_sai_thrift_set_stp_port_state_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->stp_port_state);
          this->__isset.stp_port_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stp_port_state", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->stp_port_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_pargs::~switch_sai_rpc_sai_thrift_set_stp_port_state_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stp_port_state", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte((*(this->stp_port_state)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_result::~switch_sai_rpc_sai_thrift_set_stp_port_state_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_stp_port_state_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_stp_port_state_presult::~switch_sai_rpc_sai_thrift_set_stp_port_state_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_stp_port_state_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_args::~switch_sai_rpc_sai_thrift_get_stp_port_state_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->stp_id);
          this->__isset.stp_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port_id);
          this->__isset.port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_args");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->stp_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_pargs::~switch_sai_rpc_sai_thrift_get_stp_port_state_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_pargs");

  xfer += oprot->writeFieldBegin("stp_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->stp_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_result::~switch_sai_rpc_sai_thrift_get_stp_port_state_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_stp_port_state_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BYTE, 0);
    xfer += oprot->writeByte(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_stp_port_state_presult::~switch_sai_rpc_sai_thrift_get_stp_port_state_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_stp_port_state_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_args::~switch_sai_rpc_sai_thrift_create_neighbor_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->thrift_attr_list.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += this->thrift_attr_list[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter218;
    for (_iter218 = this->thrift_attr_list.begin(); _iter218 != this->thrift_attr_list.end(); ++_iter218)
    {
      xfer += (*_iter218).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs::~switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter219;
    for (_iter219 = (*(this->thrift_attr_list)).begin(); _iter219 != (*(this->thrift_attr_list)).end(); ++_iter219)
    {
      xfer += (*_iter219).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_result::~switch_sai_rpc_sai_thrift_create_neighbor_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_neighbor_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_neighbor_entry_presult::~switch_sai_rpc_sai_thrift_create_neighbor_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_neighbor_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_neighbor_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult::~switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_neighbor_entry.read(iprot);
          this->__isset.thrift_neighbor_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            this->thrift_attr.resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += this->thrift_attr[_i224].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->thrift_neighbor_entry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter225;
    for (_iter225 = this->thrift_attr.begin(); _iter225 != this->thrift_attr.end(); ++_iter225)
    {
      xfer += (*_iter225).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_neighbor_entry", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->thrift_neighbor_entry)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter226;
    for (_iter226 = (*(this->thrift_attr)).begin(); _iter226 != (*(this->thrift_attr)).end(); ++_iter226)
    {
      xfer += (*_iter226).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_args::~switch_sai_rpc_sai_thrift_get_switch_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_pargs::~switch_sai_rpc_sai_thrift_get_switch_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_result::~switch_sai_rpc_sai_thrift_get_switch_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_attribute_presult::~switch_sai_rpc_sai_thrift_get_switch_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult::~switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_args::~switch_sai_rpc_sai_thrift_get_cpu_port_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs::~switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_result::~switch_sai_rpc_sai_thrift_get_cpu_port_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_cpu_port_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_cpu_port_id_presult::~switch_sai_rpc_sai_thrift_get_cpu_port_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_cpu_port_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_args::~switch_sai_rpc_sai_thrift_get_default_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_pargs::~switch_sai_rpc_sai_thrift_get_default_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_result::~switch_sai_rpc_sai_thrift_get_default_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_trap_group_presult::~switch_sai_rpc_sai_thrift_get_default_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_args::~switch_sai_rpc_sai_thrift_get_default_router_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_pargs::~switch_sai_rpc_sai_thrift_get_default_router_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_result::~switch_sai_rpc_sai_thrift_get_default_router_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_router_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_router_id_presult::~switch_sai_rpc_sai_thrift_get_default_router_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_router_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult::~switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_args::~switch_sai_rpc_sai_thrift_get_default_vlan_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs::~switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_result::~switch_sai_rpc_sai_thrift_get_default_vlan_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_default_vlan_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_default_vlan_id_presult::~switch_sai_rpc_sai_thrift_get_default_vlan_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_default_vlan_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_name);
          this->__isset.port_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->port_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs");

  xfer += oprot->writeFieldBegin("port_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->port_name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult::~switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_args::~switch_sai_rpc_sai_thrift_set_switch_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attribute.read(iprot);
          this->__isset.attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_args");

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->attribute.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_pargs::~switch_sai_rpc_sai_thrift_set_switch_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_pargs");

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->attribute)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_result::~switch_sai_rpc_sai_thrift_set_switch_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_switch_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_switch_attribute_presult::~switch_sai_rpc_sai_thrift_set_switch_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_switch_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args::~switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_counter_id);
          this->__isset.thrift_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs::~switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs");

  xfer += oprot->writeFieldBegin("thrift_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result::~switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_presult::~switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_args::~switch_sai_rpc_sai_thrift_create_bridge_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size227;
            ::apache::thrift::protocol::TType _etype230;
            xfer += iprot->readListBegin(_etype230, _size227);
            this->thrift_attr_list.resize(_size227);
            uint32_t _i231;
            for (_i231 = 0; _i231 < _size227; ++_i231)
            {
              xfer += this->thrift_attr_list[_i231].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter232;
    for (_iter232 = this->thrift_attr_list.begin(); _iter232 != this->thrift_attr_list.end(); ++_iter232)
    {
      xfer += (*_iter232).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_pargs::~switch_sai_rpc_sai_thrift_create_bridge_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter233;
    for (_iter233 = (*(this->thrift_attr_list)).begin(); _iter233 != (*(this->thrift_attr_list)).end(); ++_iter233)
    {
      xfer += (*_iter233).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_result::~switch_sai_rpc_sai_thrift_create_bridge_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_port_presult::~switch_sai_rpc_sai_thrift_create_bridge_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_args::~switch_sai_rpc_sai_thrift_remove_bridge_port_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_pargs::~switch_sai_rpc_sai_thrift_remove_bridge_port_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_result::~switch_sai_rpc_sai_thrift_remove_bridge_port_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_port_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_port_presult::~switch_sai_rpc_sai_thrift_remove_bridge_port_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_port_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_args::~switch_sai_rpc_sai_thrift_get_bridge_port_list_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_result::~switch_sai_rpc_sai_thrift_get_bridge_port_list_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_list_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_list_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_list_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_list_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_port_id);
          this->__isset.bridge_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("bridge_port_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult::~switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_args::~switch_sai_rpc_sai_thrift_create_bridge_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->thrift_attr_list.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += this->thrift_attr_list[_i238].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter239;
    for (_iter239 = this->thrift_attr_list.begin(); _iter239 != this->thrift_attr_list.end(); ++_iter239)
    {
      xfer += (*_iter239).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_pargs::~switch_sai_rpc_sai_thrift_create_bridge_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter240;
    for (_iter240 = (*(this->thrift_attr_list)).begin(); _iter240 != (*(this->thrift_attr_list)).end(); ++_iter240)
    {
      xfer += (*_iter240).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_result::~switch_sai_rpc_sai_thrift_create_bridge_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_bridge_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_bridge_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_bridge_presult::~switch_sai_rpc_sai_thrift_create_bridge_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_bridge_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_args::~switch_sai_rpc_sai_thrift_remove_bridge_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bridge_id);
          this->__isset.bridge_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_args");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->bridge_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_pargs::~switch_sai_rpc_sai_thrift_remove_bridge_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_pargs");

  xfer += oprot->writeFieldBegin("bridge_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->bridge_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_result::~switch_sai_rpc_sai_thrift_remove_bridge_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_bridge_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_bridge_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_bridge_presult::~switch_sai_rpc_sai_thrift_remove_bridge_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_bridge_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_args::~switch_sai_rpc_sai_thrift_create_hostif_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->thrift_attr_list.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->thrift_attr_list[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter246;
    for (_iter246 = this->thrift_attr_list.begin(); _iter246 != this->thrift_attr_list.end(); ++_iter246)
    {
      xfer += (*_iter246).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_pargs::~switch_sai_rpc_sai_thrift_create_hostif_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter247;
    for (_iter247 = (*(this->thrift_attr_list)).begin(); _iter247 != (*(this->thrift_attr_list)).end(); ++_iter247)
    {
      xfer += (*_iter247).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_result::~switch_sai_rpc_sai_thrift_create_hostif_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_presult::~switch_sai_rpc_sai_thrift_create_hostif_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_args::~switch_sai_rpc_sai_thrift_remove_hostif_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_result::~switch_sai_rpc_sai_thrift_remove_hostif_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_presult::~switch_sai_rpc_sai_thrift_remove_hostif_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_id);
          this->__isset.thrift_hif_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->thrift_attr_list.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += this->thrift_attr_list[_i252].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter253;
    for (_iter253 = this->thrift_attr_list.begin(); _iter253 != this->thrift_attr_list.end(); ++_iter253)
    {
      xfer += (*_iter253).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter254;
    for (_iter254 = (*(this->thrift_attr_list)).begin(); _iter254 != (*(this->thrift_attr_list)).end(); ++_iter254)
    {
      xfer += (*_iter254).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult::~switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_table_entry_id);
          this->__isset.thrift_hif_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_hif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult::~switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hif_table_entry_id);
          this->__isset.thrift_hif_table_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hif_table_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hif_table_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hif_table_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size255;
            ::apache::thrift::protocol::TType _etype258;
            xfer += iprot->readListBegin(_etype258, _size255);
            this->thrift_attr_list.resize(_size255);
            uint32_t _i259;
            for (_i259 = 0; _i259 < _size255; ++_i259)
            {
              xfer += this->thrift_attr_list[_i259].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter260;
    for (_iter260 = this->thrift_attr_list.begin(); _iter260 != this->thrift_attr_list.end(); ++_iter260)
    {
      xfer += (*_iter260).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter261;
    for (_iter261 = (*(this->thrift_attr_list)).begin(); _iter261 != (*(this->thrift_attr_list)).end(); ++_iter261)
    {
      xfer += (*_iter261).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult::~switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_group_id);
          this->__isset.thrift_hostif_trap_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult::~switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_group_id);
          this->__isset.thrift_hostif_trap_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_args::~switch_sai_rpc_sai_thrift_create_hostif_trap_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->thrift_attr_list.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += this->thrift_attr_list[_i266].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter267;
    for (_iter267 = this->thrift_attr_list.begin(); _iter267 != this->thrift_attr_list.end(); ++_iter267)
    {
      xfer += (*_iter267).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_pargs::~switch_sai_rpc_sai_thrift_create_hostif_trap_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter268;
    for (_iter268 = (*(this->thrift_attr_list)).begin(); _iter268 != (*(this->thrift_attr_list)).end(); ++_iter268)
    {
      xfer += (*_iter268).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_result::~switch_sai_rpc_sai_thrift_create_hostif_trap_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_hostif_trap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_hostif_trap_presult::~switch_sai_rpc_sai_thrift_create_hostif_trap_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_hostif_trap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_args::~switch_sai_rpc_sai_thrift_remove_hostif_trap_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_id);
          this->__isset.thrift_hostif_trap_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs::~switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_result::~switch_sai_rpc_sai_thrift_remove_hostif_trap_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_hostif_trap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_hostif_trap_presult::~switch_sai_rpc_sai_thrift_remove_hostif_trap_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_hostif_trap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_hostif_trap_id);
          this->__isset.thrift_hostif_trap_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_hostif_trap_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_hostif_trap_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_hostif_trap_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult::~switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_args::~switch_sai_rpc_sai_thrift_create_acl_table_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size269;
            ::apache::thrift::protocol::TType _etype272;
            xfer += iprot->readListBegin(_etype272, _size269);
            this->thrift_attr_list.resize(_size269);
            uint32_t _i273;
            for (_i273 = 0; _i273 < _size269; ++_i273)
            {
              xfer += this->thrift_attr_list[_i273].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter274;
    for (_iter274 = this->thrift_attr_list.begin(); _iter274 != this->thrift_attr_list.end(); ++_iter274)
    {
      xfer += (*_iter274).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter275;
    for (_iter275 = (*(this->thrift_attr_list)).begin(); _iter275 != (*(this->thrift_attr_list)).end(); ++_iter275)
    {
      xfer += (*_iter275).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_result::~switch_sai_rpc_sai_thrift_create_acl_table_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_presult::~switch_sai_rpc_sai_thrift_create_acl_table_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_args::~switch_sai_rpc_sai_thrift_remove_acl_table_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_id);
          this->__isset.acl_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_args");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_pargs");

  xfer += oprot->writeFieldBegin("acl_table_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_result::~switch_sai_rpc_sai_thrift_remove_acl_table_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_args::~switch_sai_rpc_sai_thrift_create_acl_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->thrift_attr_list.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->thrift_attr_list[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter281;
    for (_iter281 = this->thrift_attr_list.begin(); _iter281 != this->thrift_attr_list.end(); ++_iter281)
    {
      xfer += (*_iter281).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_pargs::~switch_sai_rpc_sai_thrift_create_acl_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter282;
    for (_iter282 = (*(this->thrift_attr_list)).begin(); _iter282 != (*(this->thrift_attr_list)).end(); ++_iter282)
    {
      xfer += (*_iter282).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_result::~switch_sai_rpc_sai_thrift_create_acl_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_entry_presult::~switch_sai_rpc_sai_thrift_create_acl_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_args::~switch_sai_rpc_sai_thrift_remove_acl_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_entry);
          this->__isset.acl_entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_args");

  xfer += oprot->writeFieldBegin("acl_entry", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_entry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_pargs::~switch_sai_rpc_sai_thrift_remove_acl_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_pargs");

  xfer += oprot->writeFieldBegin("acl_entry", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_entry)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_result::~switch_sai_rpc_sai_thrift_remove_acl_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_entry_presult::~switch_sai_rpc_sai_thrift_remove_acl_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_args::~switch_sai_rpc_sai_thrift_create_acl_table_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->thrift_attr_list.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              xfer += this->thrift_attr_list[_i287].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter288;
    for (_iter288 = this->thrift_attr_list.begin(); _iter288 != this->thrift_attr_list.end(); ++_iter288)
    {
      xfer += (*_iter288).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter289;
    for (_iter289 = (*(this->thrift_attr_list)).begin(); _iter289 != (*(this->thrift_attr_list)).end(); ++_iter289)
    {
      xfer += (*_iter289).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_result::~switch_sai_rpc_sai_thrift_create_acl_table_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_presult::~switch_sai_rpc_sai_thrift_create_acl_table_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_args::~switch_sai_rpc_sai_thrift_remove_acl_table_group_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_id);
          this->__isset.acl_table_group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_args");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_result::~switch_sai_rpc_sai_thrift_remove_acl_table_group_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_group_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size290;
            ::apache::thrift::protocol::TType _etype293;
            xfer += iprot->readListBegin(_etype293, _size290);
            this->thrift_attr_list.resize(_size290);
            uint32_t _i294;
            for (_i294 = 0; _i294 < _size290; ++_i294)
            {
              xfer += this->thrift_attr_list[_i294].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter295;
    for (_iter295 = this->thrift_attr_list.begin(); _iter295 != this->thrift_attr_list.end(); ++_iter295)
    {
      xfer += (*_iter295).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter296;
    for (_iter296 = (*(this->thrift_attr_list)).begin(); _iter296 != (*(this->thrift_attr_list)).end(); ++_iter296)
    {
      xfer += (*_iter296).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_table_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult::~switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_table_group_member_id);
          this->__isset.acl_table_group_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_table_group_member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs");

  xfer += oprot->writeFieldBegin("acl_table_group_member_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_table_group_member_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult::~switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_args::~switch_sai_rpc_sai_thrift_create_acl_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->thrift_attr_list.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += this->thrift_attr_list[_i301].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter302;
    for (_iter302 = this->thrift_attr_list.begin(); _iter302 != this->thrift_attr_list.end(); ++_iter302)
    {
      xfer += (*_iter302).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_pargs::~switch_sai_rpc_sai_thrift_create_acl_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter303;
    for (_iter303 = (*(this->thrift_attr_list)).begin(); _iter303 != (*(this->thrift_attr_list)).end(); ++_iter303)
    {
      xfer += (*_iter303).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_result::~switch_sai_rpc_sai_thrift_create_acl_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_acl_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_acl_counter_presult::~switch_sai_rpc_sai_thrift_create_acl_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_acl_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_args::~switch_sai_rpc_sai_thrift_remove_acl_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_counter_id);
          this->__isset.acl_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_args");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_pargs::~switch_sai_rpc_sai_thrift_remove_acl_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_pargs");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_result::~switch_sai_rpc_sai_thrift_remove_acl_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_acl_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_acl_counter_presult::~switch_sai_rpc_sai_thrift_remove_acl_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_acl_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->acl_counter_id);
          this->__isset.acl_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_ids.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _etype307;
            xfer += iprot->readListBegin(_etype307, _size304);
            this->thrift_attr_ids.resize(_size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              xfer += iprot->readI32(this->thrift_attr_ids[_i308]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->acl_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_attr_ids.size()));
    std::vector<int32_t> ::const_iterator _iter309;
    for (_iter309 = this->thrift_attr_ids.begin(); _iter309 != this->thrift_attr_ids.end(); ++_iter309)
    {
      xfer += oprot->writeI32((*_iter309));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("acl_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->acl_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_attr_ids)).size()));
    std::vector<int32_t> ::const_iterator _iter310;
    for (_iter310 = (*(this->thrift_attr_ids)).begin(); _iter310 != (*(this->thrift_attr_ids)).end(); ++_iter310)
    {
      xfer += oprot->writeI32((*_iter310));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readListBegin(_etype314, _size311);
            this->success.resize(_size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              xfer += this->success[_i315].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<sai_thrift_attribute_value_t> ::const_iterator _iter316;
      for (_iter316 = this->success.begin(); _iter316 != this->success.end(); ++_iter316)
      {
        xfer += (*_iter316).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult::~switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            (*(this->success)).resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += (*(this->success))[_i321].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_args::~switch_sai_rpc_sai_thrift_create_mirror_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _etype325;
            xfer += iprot->readListBegin(_etype325, _size322);
            this->thrift_attr_list.resize(_size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              xfer += this->thrift_attr_list[_i326].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter327;
    for (_iter327 = this->thrift_attr_list.begin(); _iter327 != this->thrift_attr_list.end(); ++_iter327)
    {
      xfer += (*_iter327).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_pargs::~switch_sai_rpc_sai_thrift_create_mirror_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter328;
    for (_iter328 = (*(this->thrift_attr_list)).begin(); _iter328 != (*(this->thrift_attr_list)).end(); ++_iter328)
    {
      xfer += (*_iter328).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_result::~switch_sai_rpc_sai_thrift_create_mirror_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_mirror_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_mirror_session_presult::~switch_sai_rpc_sai_thrift_create_mirror_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_mirror_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_args::~switch_sai_rpc_sai_thrift_remove_mirror_session_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_pargs::~switch_sai_rpc_sai_thrift_remove_mirror_session_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_result::~switch_sai_rpc_sai_thrift_remove_mirror_session_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_mirror_session_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_mirror_session_presult::~switch_sai_rpc_sai_thrift_remove_mirror_session_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_mirror_session_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args::~switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs::~switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result::~switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_mirror_session_attribute_presult::~switch_sai_rpc_sai_thrift_set_mirror_session_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_mirror_session_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_args::~switch_sai_rpc_sai_thrift_create_policer_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size329;
            ::apache::thrift::protocol::TType _etype332;
            xfer += iprot->readListBegin(_etype332, _size329);
            this->thrift_attr_list.resize(_size329);
            uint32_t _i333;
            for (_i333 = 0; _i333 < _size329; ++_i333)
            {
              xfer += this->thrift_attr_list[_i333].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_policer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter334;
    for (_iter334 = this->thrift_attr_list.begin(); _iter334 != this->thrift_attr_list.end(); ++_iter334)
    {
      xfer += (*_iter334).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_pargs::~switch_sai_rpc_sai_thrift_create_policer_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter335;
    for (_iter335 = (*(this->thrift_attr_list)).begin(); _iter335 != (*(this->thrift_attr_list)).end(); ++_iter335)
    {
      xfer += (*_iter335).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_result::~switch_sai_rpc_sai_thrift_create_policer_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_policer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_policer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_policer_presult::~switch_sai_rpc_sai_thrift_create_policer_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_policer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_args::~switch_sai_rpc_sai_thrift_remove_policer_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_policer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_pargs::~switch_sai_rpc_sai_thrift_remove_policer_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_result::~switch_sai_rpc_sai_thrift_remove_policer_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_policer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_policer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_policer_presult::~switch_sai_rpc_sai_thrift_remove_policer_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_policer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_args::~switch_sai_rpc_sai_thrift_set_policer_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_pargs::~switch_sai_rpc_sai_thrift_set_policer_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_result::~switch_sai_rpc_sai_thrift_set_policer_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_policer_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_policer_attribute_presult::~switch_sai_rpc_sai_thrift_set_policer_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_policer_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_args::~switch_sai_rpc_sai_thrift_get_policer_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->thrift_counter_ids.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i340]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter341;
    for (_iter341 = this->thrift_counter_ids.begin(); _iter341 != this->thrift_counter_ids.end(); ++_iter341)
    {
      xfer += oprot->writeI32((*_iter341));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_pargs::~switch_sai_rpc_sai_thrift_get_policer_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter342;
    for (_iter342 = (*(this->thrift_counter_ids)).begin(); _iter342 != (*(this->thrift_counter_ids)).end(); ++_iter342)
    {
      xfer += oprot->writeI32((*_iter342));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_result::~switch_sai_rpc_sai_thrift_get_policer_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size343;
            ::apache::thrift::protocol::TType _etype346;
            xfer += iprot->readListBegin(_etype346, _size343);
            this->success.resize(_size343);
            uint32_t _i347;
            for (_i347 = 0; _i347 < _size343; ++_i347)
            {
              xfer += iprot->readI64(this->success[_i347]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_policer_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<sai_thrift_uint64_t> ::const_iterator _iter348;
      for (_iter348 = this->success.begin(); _iter348 != this->success.end(); ++_iter348)
      {
        xfer += oprot->writeI64((*_iter348));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_policer_stats_presult::~switch_sai_rpc_sai_thrift_get_policer_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_policer_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size349;
            ::apache::thrift::protocol::TType _etype352;
            xfer += iprot->readListBegin(_etype352, _size349);
            (*(this->success)).resize(_size349);
            uint32_t _i353;
            for (_i353 = 0; _i353 < _size349; ++_i353)
            {
              xfer += iprot->readI64((*(this->success))[_i353]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_args::~switch_sai_rpc_sai_thrift_clear_policer_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_policer_id);
          this->__isset.thrift_policer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_counter_ids.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->thrift_counter_ids.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += iprot->readI32(this->thrift_counter_ids[_i358]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_args");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_policer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->thrift_counter_ids.size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter359;
    for (_iter359 = this->thrift_counter_ids.begin(); _iter359 != this->thrift_counter_ids.end(); ++_iter359)
    {
      xfer += oprot->writeI32((*_iter359));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_pargs::~switch_sai_rpc_sai_thrift_clear_policer_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_pargs");

  xfer += oprot->writeFieldBegin("thrift_policer_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_policer_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->thrift_counter_ids)).size()));
    std::vector<sai_thrift_policer_stat_t> ::const_iterator _iter360;
    for (_iter360 = (*(this->thrift_counter_ids)).begin(); _iter360 != (*(this->thrift_counter_ids)).end(); ++_iter360)
    {
      xfer += oprot->writeI32((*_iter360));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_result::~switch_sai_rpc_sai_thrift_clear_policer_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_policer_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_policer_stats_presult::~switch_sai_rpc_sai_thrift_clear_policer_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_policer_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_args::~switch_sai_rpc_sai_thrift_create_scheduler_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _etype364;
            xfer += iprot->readListBegin(_etype364, _size361);
            this->thrift_attr_list.resize(_size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              xfer += this->thrift_attr_list[_i365].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter366;
    for (_iter366 = this->thrift_attr_list.begin(); _iter366 != this->thrift_attr_list.end(); ++_iter366)
    {
      xfer += (*_iter366).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs::~switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter367;
    for (_iter367 = (*(this->thrift_attr_list)).begin(); _iter367 != (*(this->thrift_attr_list)).end(); ++_iter367)
    {
      xfer += (*_iter367).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_result::~switch_sai_rpc_sai_thrift_create_scheduler_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_scheduler_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_scheduler_profile_presult::~switch_sai_rpc_sai_thrift_create_scheduler_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_scheduler_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scheduler_id);
          this->__isset.scheduler_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_args");

  xfer += oprot->writeFieldBegin("scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->scheduler_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs");

  xfer += oprot->writeFieldBegin("scheduler_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->scheduler_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_scheduler_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult::~switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_args::~switch_sai_rpc_sai_thrift_get_queue_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size368;
            ::apache::thrift::protocol::TType _etype371;
            xfer += iprot->readListBegin(_etype371, _size368);
            this->counter_ids.resize(_size368);
            uint32_t _i372;
            for (_i372 = 0; _i372 < _size368; ++_i372)
            {
              xfer += iprot->readI32(this->counter_ids[_i372]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter373;
    for (_iter373 = this->counter_ids.begin(); _iter373 != this->counter_ids.end(); ++_iter373)
    {
      xfer += oprot->writeI32((*_iter373));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_pargs::~switch_sai_rpc_sai_thrift_get_queue_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter374;
    for (_iter374 = (*(this->counter_ids)).begin(); _iter374 != (*(this->counter_ids)).end(); ++_iter374)
    {
      xfer += oprot->writeI32((*_iter374));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_result::~switch_sai_rpc_sai_thrift_get_queue_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _etype378;
            xfer += iprot->readListBegin(_etype378, _size375);
            this->success.resize(_size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              xfer += iprot->readI64(this->success[_i379]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_queue_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter380;
      for (_iter380 = this->success.begin(); _iter380 != this->success.end(); ++_iter380)
      {
        xfer += oprot->writeI64((*_iter380));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_queue_stats_presult::~switch_sai_rpc_sai_thrift_get_queue_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_queue_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size381;
            ::apache::thrift::protocol::TType _etype384;
            xfer += iprot->readListBegin(_etype384, _size381);
            (*(this->success)).resize(_size381);
            uint32_t _i385;
            for (_i385 = 0; _i385 < _size381; ++_i385)
            {
              xfer += iprot->readI64((*(this->success))[_i385]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_args::~switch_sai_rpc_sai_thrift_clear_queue_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size386;
            ::apache::thrift::protocol::TType _etype389;
            xfer += iprot->readListBegin(_etype389, _size386);
            this->counter_ids.resize(_size386);
            uint32_t _i390;
            for (_i390 = 0; _i390 < _size386; ++_i390)
            {
              xfer += iprot->readI32(this->counter_ids[_i390]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter391;
    for (_iter391 = this->counter_ids.begin(); _iter391 != this->counter_ids.end(); ++_iter391)
    {
      xfer += oprot->writeI32((*_iter391));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_pargs::~switch_sai_rpc_sai_thrift_clear_queue_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_queue_stat_counter_t> ::const_iterator _iter392;
    for (_iter392 = (*(this->counter_ids)).begin(); _iter392 != (*(this->counter_ids)).end(); ++_iter392)
    {
      xfer += oprot->writeI32((*_iter392));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_result::~switch_sai_rpc_sai_thrift_clear_queue_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_queue_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_queue_stats_presult::~switch_sai_rpc_sai_thrift_clear_queue_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_queue_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_args::~switch_sai_rpc_sai_thrift_set_queue_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_id);
          this->__isset.queue_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_args");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->queue_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_pargs::~switch_sai_rpc_sai_thrift_set_queue_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_pargs");

  xfer += oprot->writeFieldBegin("queue_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->queue_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_result::~switch_sai_rpc_sai_thrift_set_queue_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_queue_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_queue_attribute_presult::~switch_sai_rpc_sai_thrift_set_queue_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_queue_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_args::~switch_sai_rpc_sai_thrift_create_buffer_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size393;
            ::apache::thrift::protocol::TType _etype396;
            xfer += iprot->readListBegin(_etype396, _size393);
            this->thrift_attr_list.resize(_size393);
            uint32_t _i397;
            for (_i397 = 0; _i397 < _size393; ++_i397)
            {
              xfer += this->thrift_attr_list[_i397].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter398;
    for (_iter398 = this->thrift_attr_list.begin(); _iter398 != this->thrift_attr_list.end(); ++_iter398)
    {
      xfer += (*_iter398).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_pargs::~switch_sai_rpc_sai_thrift_create_buffer_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter399;
    for (_iter399 = (*(this->thrift_attr_list)).begin(); _iter399 != (*(this->thrift_attr_list)).end(); ++_iter399)
    {
      xfer += (*_iter399).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_result::~switch_sai_rpc_sai_thrift_create_buffer_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_buffer_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_buffer_profile_presult::~switch_sai_rpc_sai_thrift_create_buffer_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_buffer_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_args::~switch_sai_rpc_sai_thrift_create_pool_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _etype403;
            xfer += iprot->readListBegin(_etype403, _size400);
            this->thrift_attr_list.resize(_size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              xfer += this->thrift_attr_list[_i404].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter405;
    for (_iter405 = this->thrift_attr_list.begin(); _iter405 != this->thrift_attr_list.end(); ++_iter405)
    {
      xfer += (*_iter405).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_pargs::~switch_sai_rpc_sai_thrift_create_pool_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter406;
    for (_iter406 = (*(this->thrift_attr_list)).begin(); _iter406 != (*(this->thrift_attr_list)).end(); ++_iter406)
    {
      xfer += (*_iter406).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_result::~switch_sai_rpc_sai_thrift_create_pool_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_pool_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_pool_profile_presult::~switch_sai_rpc_sai_thrift_create_pool_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_pool_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args::~switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffer_pool_id);
          this->__isset.buffer_pool_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _etype410;
            xfer += iprot->readListBegin(_etype410, _size407);
            this->counter_ids.resize(_size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              xfer += iprot->readI32(this->counter_ids[_i411]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args");

  xfer += oprot->writeFieldBegin("buffer_pool_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->buffer_pool_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_buffer_pool_stat_counter_t> ::const_iterator _iter412;
    for (_iter412 = this->counter_ids.begin(); _iter412 != this->counter_ids.end(); ++_iter412)
    {
      xfer += oprot->writeI32((*_iter412));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs::~switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs");

  xfer += oprot->writeFieldBegin("buffer_pool_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->buffer_pool_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_buffer_pool_stat_counter_t> ::const_iterator _iter413;
    for (_iter413 = (*(this->counter_ids)).begin(); _iter413 != (*(this->counter_ids)).end(); ++_iter413)
    {
      xfer += oprot->writeI32((*_iter413));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result::~switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size414;
            ::apache::thrift::protocol::TType _etype417;
            xfer += iprot->readListBegin(_etype417, _size414);
            this->success.resize(_size414);
            uint32_t _i418;
            for (_i418 = 0; _i418 < _size414; ++_i418)
            {
              xfer += iprot->readI64(this->success[_i418]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter419;
      for (_iter419 = this->success.begin(); _iter419 != this->success.end(); ++_iter419)
      {
        xfer += oprot->writeI64((*_iter419));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_buffer_pool_stats_presult::~switch_sai_rpc_sai_thrift_get_buffer_pool_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_buffer_pool_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size420;
            ::apache::thrift::protocol::TType _etype423;
            xfer += iprot->readListBegin(_etype423, _size420);
            (*(this->success)).resize(_size420);
            uint32_t _i424;
            for (_i424 = 0; _i424 < _size420; ++_i424)
            {
              xfer += iprot->readI64((*(this->success))[_i424]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args::~switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->buffer_pool_id);
          this->__isset.buffer_pool_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size425;
            ::apache::thrift::protocol::TType _etype428;
            xfer += iprot->readListBegin(_etype428, _size425);
            this->counter_ids.resize(_size425);
            uint32_t _i429;
            for (_i429 = 0; _i429 < _size425; ++_i429)
            {
              xfer += iprot->readI32(this->counter_ids[_i429]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args");

  xfer += oprot->writeFieldBegin("buffer_pool_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->buffer_pool_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_buffer_pool_stat_counter_t> ::const_iterator _iter430;
    for (_iter430 = this->counter_ids.begin(); _iter430 != this->counter_ids.end(); ++_iter430)
    {
      xfer += oprot->writeI32((*_iter430));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs::~switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs");

  xfer += oprot->writeFieldBegin("buffer_pool_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->buffer_pool_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_buffer_pool_stat_counter_t> ::const_iterator _iter431;
    for (_iter431 = (*(this->counter_ids)).begin(); _iter431 != (*(this->counter_ids)).end(); ++_iter431)
    {
      xfer += oprot->writeI32((*_iter431));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result::~switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_presult::~switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pg_id);
          this->__isset.pg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_args");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->pg_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->pg_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_priority_group_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult::~switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_args::~switch_sai_rpc_sai_thrift_get_pg_stats_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->pg_id);
          this->__isset.pg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_ids.clear();
            uint32_t _size432;
            ::apache::thrift::protocol::TType _etype435;
            xfer += iprot->readListBegin(_etype435, _size432);
            this->counter_ids.resize(_size432);
            uint32_t _i436;
            for (_i436 = 0; _i436 < _size432; ++_i436)
            {
              xfer += iprot->readI32(this->counter_ids[_i436]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_counters);
          this->__isset.number_of_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_args");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->pg_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->counter_ids.size()));
    std::vector<sai_thrift_pg_stat_counter_t> ::const_iterator _iter437;
    for (_iter437 = this->counter_ids.begin(); _iter437 != this->counter_ids.end(); ++_iter437)
    {
      xfer += oprot->writeI32((*_iter437));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number_of_counters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_pargs::~switch_sai_rpc_sai_thrift_get_pg_stats_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_pargs");

  xfer += oprot->writeFieldBegin("pg_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->pg_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_ids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->counter_ids)).size()));
    std::vector<sai_thrift_pg_stat_counter_t> ::const_iterator _iter438;
    for (_iter438 = (*(this->counter_ids)).begin(); _iter438 != (*(this->counter_ids)).end(); ++_iter438)
    {
      xfer += oprot->writeI32((*_iter438));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_counters", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->number_of_counters)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_result::~switch_sai_rpc_sai_thrift_get_pg_stats_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size439;
            ::apache::thrift::protocol::TType _etype442;
            xfer += iprot->readListBegin(_etype442, _size439);
            this->success.resize(_size439);
            uint32_t _i443;
            for (_i443 = 0; _i443 < _size439; ++_i443)
            {
              xfer += iprot->readI64(this->success[_i443]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_pg_stats_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->success.size()));
      std::vector<int64_t> ::const_iterator _iter444;
      for (_iter444 = this->success.begin(); _iter444 != this->success.end(); ++_iter444)
      {
        xfer += oprot->writeI64((*_iter444));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_pg_stats_presult::~switch_sai_rpc_sai_thrift_get_pg_stats_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_pg_stats_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _etype448;
            xfer += iprot->readListBegin(_etype448, _size445);
            (*(this->success)).resize(_size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              xfer += iprot->readI64((*(this->success))[_i449]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_args::~switch_sai_rpc_sai_thrift_create_wred_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size450);
            this->thrift_attr_list.resize(_size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              xfer += this->thrift_attr_list[_i454].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter455;
    for (_iter455 = this->thrift_attr_list.begin(); _iter455 != this->thrift_attr_list.end(); ++_iter455)
    {
      xfer += (*_iter455).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_pargs::~switch_sai_rpc_sai_thrift_create_wred_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter456;
    for (_iter456 = (*(this->thrift_attr_list)).begin(); _iter456 != (*(this->thrift_attr_list)).end(); ++_iter456)
    {
      xfer += (*_iter456).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_result::~switch_sai_rpc_sai_thrift_create_wred_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_wred_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_wred_profile_presult::~switch_sai_rpc_sai_thrift_create_wred_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_wred_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_args::~switch_sai_rpc_sai_thrift_remove_wred_profile_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->wred_id);
          this->__isset.wred_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_args");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->wred_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_pargs::~switch_sai_rpc_sai_thrift_remove_wred_profile_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_pargs");

  xfer += oprot->writeFieldBegin("wred_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->wred_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_result::~switch_sai_rpc_sai_thrift_remove_wred_profile_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_wred_profile_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_wred_profile_presult::~switch_sai_rpc_sai_thrift_remove_wred_profile_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_wred_profile_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_args::~switch_sai_rpc_sai_thrift_create_tunnel_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size457;
            ::apache::thrift::protocol::TType _etype460;
            xfer += iprot->readListBegin(_etype460, _size457);
            this->thrift_attr_list.resize(_size457);
            uint32_t _i461;
            for (_i461 = 0; _i461 < _size457; ++_i461)
            {
              xfer += this->thrift_attr_list[_i461].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter462;
    for (_iter462 = this->thrift_attr_list.begin(); _iter462 != this->thrift_attr_list.end(); ++_iter462)
    {
      xfer += (*_iter462).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter463;
    for (_iter463 = (*(this->thrift_attr_list)).begin(); _iter463 != (*(this->thrift_attr_list)).end(); ++_iter463)
    {
      xfer += (*_iter463).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_result::~switch_sai_rpc_sai_thrift_create_tunnel_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_presult::~switch_sai_rpc_sai_thrift_create_tunnel_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_args::~switch_sai_rpc_sai_thrift_remove_tunnel_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_tunnel_id);
          this->__isset.thrift_tunnel_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_args");

  xfer += oprot->writeFieldBegin("thrift_tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_tunnel_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_pargs");

  xfer += oprot->writeFieldBegin("thrift_tunnel_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_tunnel_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_result::~switch_sai_rpc_sai_thrift_remove_tunnel_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size464;
            ::apache::thrift::protocol::TType _etype467;
            xfer += iprot->readListBegin(_etype467, _size464);
            this->thrift_attr_list.resize(_size464);
            uint32_t _i468;
            for (_i468 = 0; _i468 < _size464; ++_i468)
            {
              xfer += this->thrift_attr_list[_i468].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter469;
    for (_iter469 = this->thrift_attr_list.begin(); _iter469 != this->thrift_attr_list.end(); ++_iter469)
    {
      xfer += (*_iter469).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter470;
    for (_iter470 = (*(this->thrift_attr_list)).begin(); _iter470 != (*(this->thrift_attr_list)).end(); ++_iter470)
    {
      xfer += (*_iter470).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult::~switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_tunnel_entry_id);
          this->__isset.thrift_tunnel_entry_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args");

  xfer += oprot->writeFieldBegin("thrift_tunnel_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_tunnel_entry_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs");

  xfer += oprot->writeFieldBegin("thrift_tunnel_entry_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_tunnel_entry_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult::~switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_args::~switch_sai_rpc_sai_thrift_create_qos_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size471;
            ::apache::thrift::protocol::TType _etype474;
            xfer += iprot->readListBegin(_etype474, _size471);
            this->thrift_attr_list.resize(_size471);
            uint32_t _i475;
            for (_i475 = 0; _i475 < _size471; ++_i475)
            {
              xfer += this->thrift_attr_list[_i475].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_qos_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter476;
    for (_iter476 = this->thrift_attr_list.begin(); _iter476 != this->thrift_attr_list.end(); ++_iter476)
    {
      xfer += (*_iter476).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_pargs::~switch_sai_rpc_sai_thrift_create_qos_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter477;
    for (_iter477 = (*(this->thrift_attr_list)).begin(); _iter477 != (*(this->thrift_attr_list)).end(); ++_iter477)
    {
      xfer += (*_iter477).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_result::~switch_sai_rpc_sai_thrift_create_qos_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_qos_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_qos_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_qos_map_presult::~switch_sai_rpc_sai_thrift_create_qos_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_qos_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_args::~switch_sai_rpc_sai_thrift_remove_qos_map_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->qos_map_id);
          this->__isset.qos_map_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_args");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->qos_map_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_pargs::~switch_sai_rpc_sai_thrift_remove_qos_map_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_pargs");

  xfer += oprot->writeFieldBegin("qos_map_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->qos_map_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_result::~switch_sai_rpc_sai_thrift_remove_qos_map_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_qos_map_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_qos_map_presult::~switch_sai_rpc_sai_thrift_remove_qos_map_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_qos_map_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_args::~switch_sai_rpc_sai_thrift_create_debug_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->thrift_attr_list.clear();
            uint32_t _size478;
            ::apache::thrift::protocol::TType _etype481;
            xfer += iprot->readListBegin(_etype481, _size478);
            this->thrift_attr_list.resize(_size478);
            uint32_t _i482;
            for (_i482 = 0; _i482 < _size478; ++_i482)
            {
              xfer += this->thrift_attr_list[_i482].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.thrift_attr_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_args");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->thrift_attr_list.size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter483;
    for (_iter483 = this->thrift_attr_list.begin(); _iter483 != this->thrift_attr_list.end(); ++_iter483)
    {
      xfer += (*_iter483).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_pargs::~switch_sai_rpc_sai_thrift_create_debug_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_attr_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->thrift_attr_list)).size()));
    std::vector<sai_thrift_attribute_t> ::const_iterator _iter484;
    for (_iter484 = (*(this->thrift_attr_list)).begin(); _iter484 != (*(this->thrift_attr_list)).end(); ++_iter484)
    {
      xfer += (*_iter484).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_result::~switch_sai_rpc_sai_thrift_create_debug_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_create_debug_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_create_debug_counter_presult::~switch_sai_rpc_sai_thrift_create_debug_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_create_debug_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_args::~switch_sai_rpc_sai_thrift_remove_debug_counter_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->thrift_debug_counter_id);
          this->__isset.thrift_debug_counter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_args");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->thrift_debug_counter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_pargs::~switch_sai_rpc_sai_thrift_remove_debug_counter_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_pargs");

  xfer += oprot->writeFieldBegin("thrift_debug_counter_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->thrift_debug_counter_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_result::~switch_sai_rpc_sai_thrift_remove_debug_counter_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_remove_debug_counter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_remove_debug_counter_presult::~switch_sai_rpc_sai_thrift_remove_debug_counter_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_remove_debug_counter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dc_id);
          this->__isset.dc_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->thrift_attr.read(iprot);
          this->__isset.thrift_attr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args");

  xfer += oprot->writeFieldBegin("dc_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->dc_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->thrift_attr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs");

  xfer += oprot->writeFieldBegin("dc_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->dc_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thrift_attr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->thrift_attr)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult::~switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args::~switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sys_port_id);
          this->__isset.sys_port_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args");

  xfer += oprot->writeFieldBegin("sys_port_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->sys_port_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs::~switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs");

  xfer += oprot->writeFieldBegin("sys_port_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->sys_port_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result::~switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_presult::~switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


switch_sai_rpc_sai_thrift_get_system_port_attribute_args::~switch_sai_rpc_sai_thrift_get_system_port_attribute_args() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sys_port_object_id);
          this->__isset.sys_port_object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_system_port_attribute_args");

  xfer += oprot->writeFieldBegin("sys_port_object_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sys_port_object_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs::~switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs");

  xfer += oprot->writeFieldBegin("sys_port_object_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->sys_port_object_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_system_port_attribute_result::~switch_sai_rpc_sai_thrift_get_system_port_attribute_result() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("switch_sai_rpc_sai_thrift_get_system_port_attribute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


switch_sai_rpc_sai_thrift_get_system_port_attribute_presult::~switch_sai_rpc_sai_thrift_get_system_port_attribute_presult() noexcept {
}


uint32_t switch_sai_rpc_sai_thrift_get_system_port_attribute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_port_attribute(port_id, thrift_attr);
  return recv_sai_thrift_set_port_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_port_attribute_pargs args;
  args.port_id = &port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_port_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_get_port_attribute(port_id);
  recv_sai_thrift_get_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_attribute(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_attribute_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_port_stats(port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_port_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_stats(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_clear_port_all_stats(port_id);
  return recv_sai_thrift_clear_port_all_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_port_all_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_port_all_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_port_all_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_all_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_fdb_entry(thrift_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  send_sai_thrift_delete_fdb_entry(thrift_fdb_entry);
  return recv_sai_thrift_delete_fdb_entry();
}

void switch_sai_rpcClient::send_sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_delete_fdb_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_delete_fdb_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_delete_fdb_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_delete_fdb_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_flush_fdb_entries(thrift_attr_list);
  return recv_sai_thrift_flush_fdb_entries();
}

void switch_sai_rpcClient::send_sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_flush_fdb_entries()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_flush_fdb_entries") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_flush_fdb_entries_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_flush_fdb_entries failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_fdb_entries(sai_thrift_attribute_list_t& _return)
{
  send_sai_thrift_get_fdb_entries();
  recv_sai_thrift_get_fdb_entries(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_fdb_entries()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_fdb_entries_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_fdb_entries(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_fdb_entries") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_fdb_entries_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_fdb_entries failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_vlan(thrift_attr_list);
  return recv_sai_thrift_create_vlan();
}

void switch_sai_rpcClient::send_sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_vlan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_vlan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_vlan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  send_sai_thrift_remove_vlan(vlan_oid);
  return recv_sai_thrift_remove_vlan();
}

void switch_sai_rpcClient::send_sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_pargs args;
  args.vlan_oid = &vlan_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_vlan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_vlan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_vlan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const sai_thrift_vlan_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_vlan_stats(vlan_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_vlan_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_stats(const sai_thrift_vlan_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_vlan_member(thrift_attr_list);
  return recv_sai_thrift_create_vlan_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_vlan_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_vlan_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_vlan_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_member_id)
{
  send_sai_thrift_get_vlan_member_attribute(vlan_member_id);
  recv_sai_thrift_get_vlan_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_member_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  send_sai_thrift_remove_vlan_member(vlan_member_id);
  return recv_sai_thrift_remove_vlan_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_member_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_vlan_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_vlan_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_vlan_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_id)
{
  send_sai_thrift_get_vlan_attribute(vlan_id);
  recv_sai_thrift_get_vlan_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_attribute(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const sai_thrift_object_id_t vlan_id)
{
  send_sai_thrift_get_vlan_id(vlan_id);
  recv_sai_thrift_get_vlan_id(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_vlan_id(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_id_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_vlan_id(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_vlan_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_vlan_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_id failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_vlan_attribute(vlan_oid, thrift_attr);
  return recv_sai_thrift_set_vlan_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs args;
  args.vlan_oid = &vlan_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_vlan_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_vlan_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_vlan_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_virtual_router(thrift_attr_list);
  return recv_sai_thrift_create_virtual_router();
}

void switch_sai_rpcClient::send_sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_virtual_router_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_virtual_router()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_virtual_router") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_virtual_router_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_virtual_router failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  send_sai_thrift_remove_virtual_router(vr_id);
  return recv_sai_thrift_remove_virtual_router();
}

void switch_sai_rpcClient::send_sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_virtual_router_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_virtual_router()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_virtual_router") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_virtual_router_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_virtual_router failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_route(thrift_route_entry, thrift_attr_list);
  return recv_sai_thrift_create_route();
}

void switch_sai_rpcClient::send_sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_route()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_route") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_route_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_route failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  send_sai_thrift_remove_route(thrift_route_entry);
  return recv_sai_thrift_remove_route();
}

void switch_sai_rpcClient::send_sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_route()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_route") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_route_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_route failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_router_interface(thrift_attr_list);
  return recv_sai_thrift_create_router_interface();
}

void switch_sai_rpcClient::send_sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_router_interface_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_router_interface()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_router_interface") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_router_interface_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_router_interface failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  send_sai_thrift_remove_router_interface(rif_id);
  return recv_sai_thrift_remove_router_interface();
}

void switch_sai_rpcClient::send_sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_router_interface_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_router_interface()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_router_interface") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_router_interface_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_router_interface failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_router_interface_attribute(rif_id, thrift_attr);
  return recv_sai_thrift_set_router_interface_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_router_interface_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_router_interface_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_router_interface_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop(thrift_attr_list);
  return recv_sai_thrift_create_next_hop();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  send_sai_thrift_remove_next_hop(next_hop_id);
  return recv_sai_thrift_remove_next_hop();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop_group(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  send_sai_thrift_remove_next_hop_group(nhop_group_oid);
  return recv_sai_thrift_remove_next_hop_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_next_hop_group_member(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_next_hop_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_next_hop_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  send_sai_thrift_remove_next_hop_group_member(nhop_group_member_oid);
  return recv_sai_thrift_remove_next_hop_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_next_hop_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_next_hop_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group_member failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_lag(thrift_attr_list);
  return recv_sai_thrift_create_lag();
}

void switch_sai_rpcClient::send_sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_lag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_lag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_lag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  send_sai_thrift_remove_lag(lag_id);
  return recv_sai_thrift_remove_lag();
}

void switch_sai_rpcClient::send_sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_lag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_lag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_lag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_lag_attribute(lag_id, thrift_attr);
  return recv_sai_thrift_set_lag_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_lag_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_lag_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_lag_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_lag_member(thrift_attr_list);
  return recv_sai_thrift_create_lag_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_lag_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_lag_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_lag_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  send_sai_thrift_remove_lag_member(lag_member_id);
  return recv_sai_thrift_remove_lag_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_member_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_lag_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_lag_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_lag_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag_member failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_member_id)
{
  send_sai_thrift_get_lag_member_attribute(lag_member_id);
  recv_sai_thrift_get_lag_member_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_lag_member_attribute(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_lag_member_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_member_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_stp_entry(thrift_attr_list);
  return recv_sai_thrift_create_stp_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_stp_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_stp_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_stp_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  send_sai_thrift_remove_stp_entry(stp_id);
  return recv_sai_thrift_remove_stp_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_entry_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_stp_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_stp_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_stp_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  send_sai_thrift_set_stp_port_state(stp_id, port_id, stp_port_state);
  return recv_sai_thrift_set_stp_port_state();
}

void switch_sai_rpcClient::send_sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.stp_port_state = &stp_port_state;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_stp_port_state()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_stp_port_state") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_stp_port_state_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_stp_port_state failed: unknown result");
}

sai_thrift_port_stp_port_state_t switch_sai_rpcClient::sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  send_sai_thrift_get_stp_port_state(stp_id, port_id);
  return recv_sai_thrift_get_stp_port_state();
}

void switch_sai_rpcClient::send_sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_port_stp_port_state_t switch_sai_rpcClient::recv_sai_thrift_get_stp_port_state()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_stp_port_state") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_port_stp_port_state_t _return;
  switch_sai_rpc_sai_thrift_get_stp_port_state_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_state failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_neighbor_entry(thrift_neighbor_entry, thrift_attr_list);
  return recv_sai_thrift_create_neighbor_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_create_neighbor_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_neighbor_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_create_neighbor_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_neighbor_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  send_sai_thrift_remove_neighbor_entry(thrift_neighbor_entry);
  return recv_sai_thrift_remove_neighbor_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_neighbor_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_neighbor_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_neighbor_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr)
{
  send_sai_thrift_set_neighbor_entry_attribute(thrift_neighbor_entry, thrift_attr);
  return recv_sai_thrift_set_neighbor_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_neighbor_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_neighbor_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_neighbor_entry_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return)
{
  send_sai_thrift_get_switch_attribute();
  recv_sai_thrift_get_switch_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_switch_attribute()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_attribute_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_switch_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_switch_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{
  send_sai_thrift_get_port_list_by_front_port();
  recv_sai_thrift_get_port_list_by_front_port(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_port_list_by_front_port()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_list_by_front_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_list_by_front_port failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_cpu_port_id()
{
  send_sai_thrift_get_cpu_port_id();
  return recv_sai_thrift_get_cpu_port_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_cpu_port_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_cpu_port_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_cpu_port_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_cpu_port_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_port_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_trap_group()
{
  send_sai_thrift_get_default_trap_group();
  return recv_sai_thrift_get_default_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_trap_group()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_trap_group_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_trap_group failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_router_id()
{
  send_sai_thrift_get_default_router_id();
  return recv_sai_thrift_get_default_router_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_router_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_router_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_router_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_router_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_router_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_router_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_default_1q_bridge_id()
{
  send_sai_thrift_get_default_1q_bridge_id();
  return recv_sai_thrift_get_default_1q_bridge_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_default_1q_bridge_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_default_1q_bridge_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_1q_bridge_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_1q_bridge_id failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{
  send_sai_thrift_get_default_vlan_id();
  recv_sai_thrift_get_default_vlan_id(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_default_vlan_id()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_default_vlan_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_default_vlan_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_vlan_id failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  send_sai_thrift_get_port_id_by_front_port(port_name);
  return recv_sai_thrift_get_port_id_by_front_port();
}

void switch_sai_rpcClient::send_sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs args;
  args.port_name = &port_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_port_id_by_front_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_port_id_by_front_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_id_by_front_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  send_sai_thrift_set_switch_attribute(attribute);
  return recv_sai_thrift_set_switch_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_switch_attribute_pargs args;
  args.attribute = &attribute;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_switch_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_switch_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_switch_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_switch_attribute failed: unknown result");
}

int64_t switch_sai_rpcClient::sai_thrift_get_switch_stats_by_oid(const sai_thrift_object_id_t thrift_counter_id)
{
  send_sai_thrift_get_switch_stats_by_oid(thrift_counter_id);
  return recv_sai_thrift_get_switch_stats_by_oid();
}

void switch_sai_rpcClient::send_sai_thrift_get_switch_stats_by_oid(const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats_by_oid", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t switch_sai_rpcClient::recv_sai_thrift_get_switch_stats_by_oid()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_switch_stats_by_oid") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats_by_oid failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_bridge_port(thrift_attr_list);
  recv_sai_thrift_create_bridge_port(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_bridge_port(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_bridge_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_bridge_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge_port failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  send_sai_thrift_remove_bridge_port(bridge_port_id);
  return recv_sai_thrift_remove_bridge_port();
}

void switch_sai_rpcClient::send_sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_port_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_bridge_port()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_bridge_port") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_bridge_port_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge_port failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const sai_thrift_object_id_t bridge_id)
{
  send_sai_thrift_get_bridge_port_list(bridge_id);
  recv_sai_thrift_get_bridge_port_list(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_list(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_list") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_list_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_list failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_port_id)
{
  send_sai_thrift_get_bridge_port_attribute(bridge_port_id);
  recv_sai_thrift_get_bridge_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_bridge_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_attribute failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_bridge_port_attribute(bridge_port_id, thrift_attr);
  return recv_sai_thrift_set_bridge_port_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_bridge_port_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_bridge_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_port_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_create_bridge(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_bridge(thrift_attr_list);
  recv_sai_thrift_create_bridge(_return);
}

void switch_sai_rpcClient::send_sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_create_bridge(sai_thrift_result_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_bridge") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_create_bridge_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  send_sai_thrift_remove_bridge(bridge_id);
  return recv_sai_thrift_remove_bridge();
}

void switch_sai_rpcClient::send_sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_bridge()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_bridge") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_bridge_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif(thrift_attr_list);
  return recv_sai_thrift_create_hostif();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  send_sai_thrift_remove_hostif(thrift_hif_id);
  return recv_sai_thrift_remove_hostif();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_attribute(thrift_hif_id, thrift_attr);
  return recv_sai_thrift_set_hostif_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_hostif_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_table_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hif_table_entry_id)
{
  send_sai_thrift_remove_hostif_table_entry(thrift_hif_table_entry_id);
  return recv_sai_thrift_remove_hostif_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hif_table_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs args;
  args.thrift_hif_table_entry_id = &thrift_hif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_table_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_table_entry_attribute(thrift_hif_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_hostif_table_entry_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs args;
  args.thrift_hif_table_entry_id = &thrift_hif_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_table_entry_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_table_entry_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_table_entry_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_trap_group(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  send_sai_thrift_remove_hostif_trap_group(thrift_hostif_trap_group_id);
  return recv_sai_thrift_remove_hostif_trap_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_trap_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_trap_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_trap_group_attribute(thrift_hostif_trap_group_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_trap_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_trap_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_group_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_hostif_trap(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap();
}

void switch_sai_rpcClient::send_sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_hostif_trap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_hostif_trap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_hostif_trap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  send_sai_thrift_remove_hostif_trap(thrift_hostif_trap_id);
  return recv_sai_thrift_remove_hostif_trap();
}

void switch_sai_rpcClient::send_sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_hostif_trap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_hostif_trap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_hostif_trap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_hostif_trap_attribute(thrift_hostif_trap_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_hostif_trap_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_hostif_trap_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table(thrift_attr_list);
  return recv_sai_thrift_create_acl_table();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  send_sai_thrift_remove_acl_table(acl_table_id);
  return recv_sai_thrift_remove_acl_table();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_pargs args;
  args.acl_table_id = &acl_table_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_entry(thrift_attr_list);
  return recv_sai_thrift_create_acl_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  send_sai_thrift_remove_acl_entry(acl_entry);
  return recv_sai_thrift_remove_acl_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_entry_pargs args;
  args.acl_entry = &acl_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_entry failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table_group(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  send_sai_thrift_remove_acl_table_group(acl_table_group_id);
  return recv_sai_thrift_remove_acl_table_group();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table_group()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table_group") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_group_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_table_group_member(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_table_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_table_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group_member failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  send_sai_thrift_remove_acl_table_group_member(acl_table_group_member_id);
  return recv_sai_thrift_remove_acl_table_group_member();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_table_group_member()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_table_group_member") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group_member failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_acl_counter(thrift_attr_list);
  return recv_sai_thrift_create_acl_counter();
}

void switch_sai_rpcClient::send_sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_acl_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_acl_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_acl_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  send_sai_thrift_remove_acl_counter(acl_counter_id);
  return recv_sai_thrift_remove_acl_counter();
}

void switch_sai_rpcClient::send_sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_counter_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_acl_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_acl_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_acl_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_counter failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  send_sai_thrift_get_acl_counter_attribute(acl_counter_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_counter_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_acl_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_counter_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_mirror_session(thrift_attr_list);
  return recv_sai_thrift_create_mirror_session();
}

void switch_sai_rpcClient::send_sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mirror_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_mirror_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_mirror_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_mirror_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mirror_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  send_sai_thrift_remove_mirror_session(session_id);
  return recv_sai_thrift_remove_mirror_session();
}

void switch_sai_rpcClient::send_sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mirror_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_mirror_session()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_mirror_session") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_mirror_session_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mirror_session failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t session_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_mirror_session_attribute(session_id, thrift_attr);
  return recv_sai_thrift_set_mirror_session_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_mirror_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs args;
  args.session_id = &session_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_mirror_session_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_mirror_session_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_mirror_session_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mirror_session_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_policer(thrift_attr_list);
  return recv_sai_thrift_create_policer();
}

void switch_sai_rpcClient::send_sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_policer_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_policer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_policer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_policer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_policer failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  send_sai_thrift_remove_policer(thrift_policer_id);
  return recv_sai_thrift_remove_policer();
}

void switch_sai_rpcClient::send_sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_policer_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_policer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_policer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_policer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_policer failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_policer_attribute(thrift_policer_id, thrift_attr);
  return recv_sai_thrift_set_policer_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_policer_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_policer_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_policer_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_policer_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  send_sai_thrift_get_policer_stats(thrift_policer_id, thrift_counter_ids);
  recv_sai_thrift_get_policer_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_policer_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_policer_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  send_sai_thrift_clear_policer_stats(thrift_policer_id, thrift_counter_ids);
  return recv_sai_thrift_clear_policer_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_policer_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_policer_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_policer_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_policer_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_scheduler_profile(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_scheduler_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_scheduler_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_scheduler_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  send_sai_thrift_remove_scheduler_profile(scheduler_id);
  return recv_sai_thrift_remove_scheduler_profile();
}

void switch_sai_rpcClient::send_sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs args;
  args.scheduler_id = &scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_scheduler_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_scheduler_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_profile failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_queue_stats(queue_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_queue_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_queue_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_queue_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_queue_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_clear_queue_stats(queue_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_queue_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_queue_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_queue_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_queue_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_queue_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_queue_attribute(queue_id, thrift_attr);
  return recv_sai_thrift_set_queue_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_queue_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_queue_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_queue_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_queue_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_buffer_profile(thrift_attr_list);
  return recv_sai_thrift_create_buffer_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_buffer_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_buffer_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_buffer_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_buffer_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_buffer_profile failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_pool_profile(thrift_attr_list);
  return recv_sai_thrift_create_pool_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_pool_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_pool_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_pool_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_pool_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_pool_profile failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_buffer_pool_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  send_sai_thrift_get_buffer_pool_stats(buffer_pool_id, counter_ids);
  recv_sai_thrift_get_buffer_pool_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_buffer_pool_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs args;
  args.buffer_pool_id = &buffer_pool_id;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_buffer_pool_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_buffer_pool_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_buffer_pool_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_buffer_pool_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  send_sai_thrift_clear_buffer_pool_stats(buffer_pool_id, counter_ids);
  return recv_sai_thrift_clear_buffer_pool_stats();
}

void switch_sai_rpcClient::send_sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_clear_buffer_pool_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs args;
  args.buffer_pool_id = &buffer_pool_id;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_clear_buffer_pool_stats()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_clear_buffer_pool_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_buffer_pool_stats failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_priority_group_attribute(pg_id, thrift_attr);
  return recv_sai_thrift_set_priority_group_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs args;
  args.pg_id = &pg_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_priority_group_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_priority_group_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_priority_group_attribute failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  send_sai_thrift_get_pg_stats(pg_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_pg_stats(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_pg_stats(const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_pg_stats_pargs args;
  args.pg_id = &pg_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_pg_stats(std::vector<int64_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_pg_stats") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_pg_stats_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_pg_stats failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_wred_profile(thrift_attr_list);
  return recv_sai_thrift_create_wred_profile();
}

void switch_sai_rpcClient::send_sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_wred_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_wred_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_wred_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_wred_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_wred_profile failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  send_sai_thrift_remove_wred_profile(wred_id);
  return recv_sai_thrift_remove_wred_profile();
}

void switch_sai_rpcClient::send_sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_wred_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_wred_profile()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_wred_profile") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_wred_profile_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_wred_profile failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel(thrift_attr_list);
  return recv_sai_thrift_create_tunnel();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel(const sai_thrift_object_id_t thrift_tunnel_id)
{
  send_sai_thrift_remove_tunnel(thrift_tunnel_id);
  return recv_sai_thrift_remove_tunnel();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel(const sai_thrift_object_id_t thrift_tunnel_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_pargs args;
  args.thrift_tunnel_id = &thrift_tunnel_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_tunnel_term_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_term_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_tunnel_term_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_tunnel_term_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_term_table_entry failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t thrift_tunnel_entry_id)
{
  send_sai_thrift_remove_tunnel_term_table_entry(thrift_tunnel_entry_id);
  return recv_sai_thrift_remove_tunnel_term_table_entry();
}

void switch_sai_rpcClient::send_sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t thrift_tunnel_entry_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs args;
  args.thrift_tunnel_entry_id = &thrift_tunnel_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_tunnel_term_table_entry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_tunnel_term_table_entry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_term_table_entry failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_qos_map(thrift_attr_list);
  return recv_sai_thrift_create_qos_map();
}

void switch_sai_rpcClient::send_sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_qos_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_qos_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_qos_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_qos_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_qos_map failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  send_sai_thrift_remove_qos_map(qos_map_id);
  return recv_sai_thrift_remove_qos_map();
}

void switch_sai_rpcClient::send_sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_qos_map_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_qos_map()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_qos_map") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_qos_map_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_qos_map failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  send_sai_thrift_create_debug_counter(thrift_attr_list);
  return recv_sai_thrift_create_debug_counter();
}

void switch_sai_rpcClient::send_sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_debug_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_create_debug_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_create_debug_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_create_debug_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_debug_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_remove_debug_counter(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  send_sai_thrift_remove_debug_counter(thrift_debug_counter_id);
  return recv_sai_thrift_remove_debug_counter();
}

void switch_sai_rpcClient::send_sai_thrift_remove_debug_counter(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_debug_counter_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_remove_debug_counter()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_remove_debug_counter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_remove_debug_counter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_debug_counter failed: unknown result");
}

sai_thrift_status_t switch_sai_rpcClient::sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t dc_id, const sai_thrift_attribute_t& thrift_attr)
{
  send_sai_thrift_set_debug_counter_attribute(dc_id, thrift_attr);
  return recv_sai_thrift_set_debug_counter_attribute();
}

void switch_sai_rpcClient::send_sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t dc_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs args;
  args.dc_id = &dc_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_status_t switch_sai_rpcClient::recv_sai_thrift_set_debug_counter_attribute()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_set_debug_counter_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_status_t _return;
  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_debug_counter_attribute failed: unknown result");
}

sai_thrift_object_id_t switch_sai_rpcClient::sai_thrift_get_sys_port_obj_id_by_port_id(const int32_t sys_port_id)
{
  send_sai_thrift_get_sys_port_obj_id_by_port_id(sys_port_id);
  return recv_sai_thrift_get_sys_port_obj_id_by_port_id();
}

void switch_sai_rpcClient::send_sai_thrift_get_sys_port_obj_id_by_port_id(const int32_t sys_port_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_sys_port_obj_id_by_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs args;
  args.sys_port_id = &sys_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

sai_thrift_object_id_t switch_sai_rpcClient::recv_sai_thrift_get_sys_port_obj_id_by_port_id()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_sys_port_obj_id_by_port_id") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  sai_thrift_object_id_t _return;
  switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_sys_port_obj_id_by_port_id failed: unknown result");
}

void switch_sai_rpcClient::sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t sys_port_object_id)
{
  send_sai_thrift_get_system_port_attribute(sys_port_object_id);
  recv_sai_thrift_get_system_port_attribute(_return);
}

void switch_sai_rpcClient::send_sai_thrift_get_system_port_attribute(const sai_thrift_object_id_t sys_port_object_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sai_thrift_get_system_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs args;
  args.sys_port_object_id = &sys_port_object_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void switch_sai_rpcClient::recv_sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sai_thrift_get_system_port_attribute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  switch_sai_rpc_sai_thrift_get_system_port_attribute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_system_port_attribute failed: unknown result");
}

bool switch_sai_rpcProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void switch_sai_rpcProcessor::process_sai_thrift_set_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
  }

  switch_sai_rpc_sai_thrift_set_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_port_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_port_attribute(args.port_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_attribute_result result;
  try {
    iface_->sai_thrift_get_port_attribute(result.success, args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
  }

  switch_sai_rpc_sai_thrift_get_port_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_stats_result result;
  try {
    iface_->sai_thrift_get_port_stats(result.success, args.port_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_port_all_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_port_all_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
  }

  switch_sai_rpc_sai_thrift_clear_port_all_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_port_all_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_port_all_stats(args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_port_all_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_create_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_fdb_entry(args.thrift_fdb_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_delete_fdb_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_delete_fdb_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
  }

  switch_sai_rpc_sai_thrift_delete_fdb_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_delete_fdb_entry_result result;
  try {
    result.success = iface_->sai_thrift_delete_fdb_entry(args.thrift_fdb_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry");
  }

  oprot->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_delete_fdb_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_flush_fdb_entries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_flush_fdb_entries", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
  }

  switch_sai_rpc_sai_thrift_flush_fdb_entries_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries", bytes);
  }

  switch_sai_rpc_sai_thrift_flush_fdb_entries_result result;
  try {
    result.success = iface_->sai_thrift_flush_fdb_entries(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries");
  }

  oprot->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_flush_fdb_entries", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_fdb_entries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_fdb_entries", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries");
  }

  switch_sai_rpc_sai_thrift_get_fdb_entries_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries", bytes);
  }

  switch_sai_rpc_sai_thrift_get_fdb_entries_result result;
  try {
    iface_->sai_thrift_get_fdb_entries(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_fdb_entries", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries");
  }

  oprot->writeMessageBegin("sai_thrift_get_fdb_entries", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_fdb_entries", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_vlan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_vlan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_vlan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
  }

  switch_sai_rpc_sai_thrift_create_vlan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan", bytes);
  }

  switch_sai_rpc_sai_thrift_create_vlan_result result;
  try {
    result.success = iface_->sai_thrift_create_vlan(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan");
  }

  oprot->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_vlan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_vlan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_vlan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
  }

  switch_sai_rpc_sai_thrift_remove_vlan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_vlan_result result;
  try {
    result.success = iface_->sai_thrift_remove_vlan(args.vlan_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan");
  }

  oprot->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_stats_result result;
  try {
    iface_->sai_thrift_get_vlan_stats(result.success, args.vlan_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_vlan_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_vlan_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
  }

  switch_sai_rpc_sai_thrift_create_vlan_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_vlan_member_result result;
  try {
    result.success = iface_->sai_thrift_create_vlan_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_vlan_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_result result;
  try {
    iface_->sai_thrift_get_vlan_member_attribute(result.success, args.vlan_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_vlan_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_vlan_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
  }

  switch_sai_rpc_sai_thrift_remove_vlan_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_vlan_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_vlan_member(args.vlan_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_vlan_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
  }

  switch_sai_rpc_sai_thrift_get_vlan_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_attribute_result result;
  try {
    iface_->sai_thrift_get_vlan_attribute(result.success, args.vlan_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_vlan_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_vlan_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
  }

  switch_sai_rpc_sai_thrift_get_vlan_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_vlan_id_result result;
  try {
    iface_->sai_thrift_get_vlan_id(result.success, args.vlan_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_vlan_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_vlan_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_vlan_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
  }

  switch_sai_rpc_sai_thrift_set_vlan_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_vlan_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_vlan_attribute(args.vlan_oid, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_vlan_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_virtual_router(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_virtual_router", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
  }

  switch_sai_rpc_sai_thrift_create_virtual_router_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router", bytes);
  }

  switch_sai_rpc_sai_thrift_create_virtual_router_result result;
  try {
    result.success = iface_->sai_thrift_create_virtual_router(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router");
  }

  oprot->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_virtual_router", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_virtual_router(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_virtual_router", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
  }

  switch_sai_rpc_sai_thrift_remove_virtual_router_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_virtual_router_result result;
  try {
    result.success = iface_->sai_thrift_remove_virtual_router(args.vr_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router");
  }

  oprot->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_virtual_router", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_route(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_route", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_route");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_route");
  }

  switch_sai_rpc_sai_thrift_create_route_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_route", bytes);
  }

  switch_sai_rpc_sai_thrift_create_route_result result;
  try {
    result.success = iface_->sai_thrift_create_route(args.thrift_route_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_route");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_route");
  }

  oprot->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_route", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_route(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_route", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_route");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_route");
  }

  switch_sai_rpc_sai_thrift_remove_route_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_route", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_route_result result;
  try {
    result.success = iface_->sai_thrift_remove_route(args.thrift_route_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_route");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_route");
  }

  oprot->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_route", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_router_interface(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_router_interface", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_router_interface");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
  }

  switch_sai_rpc_sai_thrift_create_router_interface_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_router_interface", bytes);
  }

  switch_sai_rpc_sai_thrift_create_router_interface_result result;
  try {
    result.success = iface_->sai_thrift_create_router_interface(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_router_interface");
  }

  oprot->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_router_interface", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_router_interface(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_router_interface", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
  }

  switch_sai_rpc_sai_thrift_remove_router_interface_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_router_interface_result result;
  try {
    result.success = iface_->sai_thrift_remove_router_interface(args.rif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface");
  }

  oprot->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_router_interface", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_router_interface_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_router_interface_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
  }

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_router_interface_attribute(args.rif_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_router_interface_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop(args.next_hop_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop_group(args.nhop_group_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_next_hop_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_next_hop_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_next_hop_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_next_hop_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_next_hop_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_next_hop_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_next_hop_group_member(args.nhop_group_member_oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_next_hop_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_lag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_lag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_lag");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_lag");
  }

  switch_sai_rpc_sai_thrift_create_lag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_lag", bytes);
  }

  switch_sai_rpc_sai_thrift_create_lag_result result;
  try {
    result.success = iface_->sai_thrift_create_lag(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_lag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag");
  }

  oprot->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_lag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_lag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_lag");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
  }

  switch_sai_rpc_sai_thrift_remove_lag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_lag_result result;
  try {
    result.success = iface_->sai_thrift_remove_lag(args.lag_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag");
  }

  oprot->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_lag_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_lag_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
  }

  switch_sai_rpc_sai_thrift_set_lag_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_lag_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_lag_attribute(args.lag_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_lag_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_lag_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_lag_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_lag_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
  }

  switch_sai_rpc_sai_thrift_create_lag_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_lag_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_lag_member_result result;
  try {
    result.success = iface_->sai_thrift_create_lag_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_lag_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_lag_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_lag_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
  }

  switch_sai_rpc_sai_thrift_remove_lag_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_lag_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_lag_member(args.lag_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_lag_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_lag_member_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_lag_member_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
  }

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_result result;
  try {
    iface_->sai_thrift_get_lag_member_attribute(result.success, args.lag_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_lag_member_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_stp_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_stp_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
  }

  switch_sai_rpc_sai_thrift_create_stp_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_stp_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_stp_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_stp_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_stp_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_stp_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
  }

  switch_sai_rpc_sai_thrift_remove_stp_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_stp_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_stp_entry(args.stp_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_stp_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_stp_port_state(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_stp_port_state", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
  }

  switch_sai_rpc_sai_thrift_set_stp_port_state_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state", bytes);
  }

  switch_sai_rpc_sai_thrift_set_stp_port_state_result result;
  try {
    result.success = iface_->sai_thrift_set_stp_port_state(args.stp_id, args.port_id, args.stp_port_state);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state");
  }

  oprot->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_stp_port_state", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_stp_port_state(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_stp_port_state", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
  }

  switch_sai_rpc_sai_thrift_get_stp_port_state_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state", bytes);
  }

  switch_sai_rpc_sai_thrift_get_stp_port_state_result result;
  try {
    result.success = iface_->sai_thrift_get_stp_port_state(args.stp_id, args.port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state");
  }

  oprot->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_stp_port_state", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_neighbor_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_neighbor_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
  }

  switch_sai_rpc_sai_thrift_create_neighbor_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_neighbor_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_neighbor_entry(args.thrift_neighbor_entry, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_neighbor_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_neighbor_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_neighbor_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
  }

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_neighbor_entry(args.thrift_neighbor_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_neighbor_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_neighbor_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_neighbor_entry_attribute(args.thrift_neighbor_entry, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_neighbor_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_switch_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_switch_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
  }

  switch_sai_rpc_sai_thrift_get_switch_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_switch_attribute_result result;
  try {
    iface_->sai_thrift_get_switch_attribute(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_list_by_front_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_list_by_front_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
  }

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_result result;
  try {
    iface_->sai_thrift_get_port_list_by_front_port(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_list_by_front_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_cpu_port_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_cpu_port_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
  }

  switch_sai_rpc_sai_thrift_get_cpu_port_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_cpu_port_id_result result;
  try {
    result.success = iface_->sai_thrift_get_cpu_port_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_cpu_port_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
  }

  switch_sai_rpc_sai_thrift_get_default_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_get_default_trap_group();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_router_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_router_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
  }

  switch_sai_rpc_sai_thrift_get_default_router_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_router_id_result result;
  try {
    result.success = iface_->sai_thrift_get_default_router_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_router_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_1q_bridge_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
  }

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_result result;
  try {
    result.success = iface_->sai_thrift_get_default_1q_bridge_id();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_1q_bridge_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_default_vlan_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_default_vlan_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
  }

  switch_sai_rpc_sai_thrift_get_default_vlan_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_default_vlan_id_result result;
  try {
    iface_->sai_thrift_get_default_vlan_id(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_default_vlan_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_port_id_by_front_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_port_id_by_front_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
  }

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port", bytes);
  }

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_result result;
  try {
    result.success = iface_->sai_thrift_get_port_id_by_front_port(args.port_name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port");
  }

  oprot->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_port_id_by_front_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_switch_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_switch_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
  }

  switch_sai_rpc_sai_thrift_set_switch_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_switch_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_switch_attribute(args.attribute);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_switch_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_switch_stats_by_oid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_switch_stats_by_oid", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid");
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid", bytes);
  }

  switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_result result;
  try {
    result.success = iface_->sai_thrift_get_switch_stats_by_oid(args.thrift_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_switch_stats_by_oid", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid");
  }

  oprot->writeMessageBegin("sai_thrift_get_switch_stats_by_oid", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_switch_stats_by_oid", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_bridge_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_bridge_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
  }

  switch_sai_rpc_sai_thrift_create_bridge_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port", bytes);
  }

  switch_sai_rpc_sai_thrift_create_bridge_port_result result;
  try {
    iface_->sai_thrift_create_bridge_port(result.success, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port");
  }

  oprot->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_bridge_port(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_bridge_port", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
  }

  switch_sai_rpc_sai_thrift_remove_bridge_port_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_bridge_port_result result;
  try {
    result.success = iface_->sai_thrift_remove_bridge_port(args.bridge_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port");
  }

  oprot->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge_port", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_list(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_list", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_list_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_list_result result;
  try {
    iface_->sai_thrift_get_bridge_port_list(result.success, args.bridge_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_list", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_bridge_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_bridge_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_result result;
  try {
    iface_->sai_thrift_get_bridge_port_attribute(result.success, args.bridge_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_bridge_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_bridge_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_bridge_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
  }

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_bridge_port_attribute(args.bridge_port_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_bridge_port_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_bridge(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_bridge", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_bridge");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
  }

  switch_sai_rpc_sai_thrift_create_bridge_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_bridge", bytes);
  }

  switch_sai_rpc_sai_thrift_create_bridge_result result;
  try {
    iface_->sai_thrift_create_bridge(result.success, args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge");
  }

  oprot->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_bridge", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_bridge(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_bridge", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_bridge");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
  }

  switch_sai_rpc_sai_thrift_remove_bridge_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_bridge", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_bridge_result result;
  try {
    result.success = iface_->sai_thrift_remove_bridge(args.bridge_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge");
  }

  oprot->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_bridge", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
  }

  switch_sai_rpc_sai_thrift_create_hostif_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif(args.thrift_hif_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_attribute(args.thrift_hif_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
  }

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_table_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_table_entry(args.thrift_hif_table_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_table_entry_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_table_entry_attribute(args.thrift_hif_table_entry_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_table_entry_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_trap_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_trap_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_trap_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_trap_group(args.thrift_hostif_trap_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_trap_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_trap_group_attribute(args.thrift_hostif_trap_group_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_hostif_trap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_hostif_trap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap", bytes);
  }

  switch_sai_rpc_sai_thrift_create_hostif_trap_result result;
  try {
    result.success = iface_->sai_thrift_create_hostif_trap(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap");
  }

  oprot->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_hostif_trap", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_hostif_trap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_hostif_trap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_hostif_trap_result result;
  try {
    result.success = iface_->sai_thrift_remove_hostif_trap(args.thrift_hostif_trap_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap");
  }

  oprot->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_hostif_trap", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_hostif_trap_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_hostif_trap_attribute(args.thrift_hostif_trap_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_hostif_trap_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table(args.acl_table_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
  }

  switch_sai_rpc_sai_thrift_create_acl_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
  }

  switch_sai_rpc_sai_thrift_remove_acl_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_entry(args.acl_entry);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table_group(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table_group(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table_group", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table_group(args.acl_table_group_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_table_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_table_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_table_group_member(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_table_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_table_group_member(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_table_group_member", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_table_group_member(args.acl_table_group_member_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_table_group_member", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_acl_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_acl_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
  }

  switch_sai_rpc_sai_thrift_create_acl_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_create_acl_counter_result result;
  try {
    result.success = iface_->sai_thrift_create_acl_counter(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter");
  }

  oprot->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_acl_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_acl_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_acl_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
  }

  switch_sai_rpc_sai_thrift_remove_acl_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_acl_counter_result result;
  try {
    result.success = iface_->sai_thrift_remove_acl_counter(args.acl_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter");
  }

  oprot->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_acl_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_acl_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_acl_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result result;
  try {
    iface_->sai_thrift_get_acl_counter_attribute(result.success, args.acl_counter_id, args.thrift_attr_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_acl_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_mirror_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_mirror_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
  }

  switch_sai_rpc_sai_thrift_create_mirror_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session", bytes);
  }

  switch_sai_rpc_sai_thrift_create_mirror_session_result result;
  try {
    result.success = iface_->sai_thrift_create_mirror_session(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session");
  }

  oprot->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_mirror_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_mirror_session(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_mirror_session", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
  }

  switch_sai_rpc_sai_thrift_remove_mirror_session_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_mirror_session_result result;
  try {
    result.success = iface_->sai_thrift_remove_mirror_session(args.session_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session");
  }

  oprot->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_mirror_session", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_mirror_session_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_mirror_session_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute");
  }

  switch_sai_rpc_sai_thrift_set_mirror_session_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_mirror_session_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_mirror_session_attribute(args.session_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_mirror_session_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_mirror_session_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_mirror_session_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_policer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_policer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_policer");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_policer");
  }

  switch_sai_rpc_sai_thrift_create_policer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_policer", bytes);
  }

  switch_sai_rpc_sai_thrift_create_policer_result result;
  try {
    result.success = iface_->sai_thrift_create_policer(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_policer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_policer");
  }

  oprot->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_policer", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_policer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_policer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_policer");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
  }

  switch_sai_rpc_sai_thrift_remove_policer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_policer", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_policer_result result;
  try {
    result.success = iface_->sai_thrift_remove_policer(args.thrift_policer_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_policer");
  }

  oprot->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_policer", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_policer_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_policer_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
  }

  switch_sai_rpc_sai_thrift_set_policer_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_policer_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_policer_attribute(args.thrift_policer_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_policer_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_policer_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_policer_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
  }

  switch_sai_rpc_sai_thrift_get_policer_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_policer_stats_result result;
  try {
    iface_->sai_thrift_get_policer_stats(result.success, args.thrift_policer_id, args.thrift_counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_policer_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_policer_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_policer_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
  }

  switch_sai_rpc_sai_thrift_clear_policer_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_policer_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_policer_stats(args.thrift_policer_id, args.thrift_counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_policer_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_scheduler_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_scheduler_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
  }

  switch_sai_rpc_sai_thrift_create_scheduler_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_scheduler_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_scheduler_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_scheduler_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_scheduler_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_scheduler_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_result result;
  try {
    result.success = iface_->sai_thrift_remove_scheduler_profile(args.scheduler_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile");
  }

  oprot->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_scheduler_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_queue_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_queue_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
  }

  switch_sai_rpc_sai_thrift_get_queue_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_queue_stats_result result;
  try {
    iface_->sai_thrift_get_queue_stats(result.success, args.queue_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_queue_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_queue_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_queue_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
  }

  switch_sai_rpc_sai_thrift_clear_queue_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_queue_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_queue_stats(args.queue_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_queue_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_queue_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_queue_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
  }

  switch_sai_rpc_sai_thrift_set_queue_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_queue_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_queue_attribute(args.queue_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_queue_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_buffer_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_buffer_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
  }

  switch_sai_rpc_sai_thrift_create_buffer_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_buffer_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_buffer_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_buffer_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_pool_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_pool_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
  }

  switch_sai_rpc_sai_thrift_create_pool_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_pool_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_pool_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_pool_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_buffer_pool_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_buffer_pool_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats");
  }

  switch_sai_rpc_sai_thrift_get_buffer_pool_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_buffer_pool_stats_result result;
  try {
    iface_->sai_thrift_get_buffer_pool_stats(result.success, args.buffer_pool_id, args.counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_buffer_pool_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_buffer_pool_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_buffer_pool_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_clear_buffer_pool_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_clear_buffer_pool_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats");
  }

  switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_result result;
  try {
    result.success = iface_->sai_thrift_clear_buffer_pool_stats(args.buffer_pool_id, args.counter_ids);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_clear_buffer_pool_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats");
  }

  oprot->writeMessageBegin("sai_thrift_clear_buffer_pool_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_clear_buffer_pool_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_priority_group_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_priority_group_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
  }

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_priority_group_attribute(args.pg_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_priority_group_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_pg_stats(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_pg_stats", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
  }

  switch_sai_rpc_sai_thrift_get_pg_stats_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats", bytes);
  }

  switch_sai_rpc_sai_thrift_get_pg_stats_result result;
  try {
    iface_->sai_thrift_get_pg_stats(result.success, args.pg_id, args.counter_ids, args.number_of_counters);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats");
  }

  oprot->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_pg_stats", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_wred_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_wred_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
  }

  switch_sai_rpc_sai_thrift_create_wred_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_create_wred_profile_result result;
  try {
    result.success = iface_->sai_thrift_create_wred_profile(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile");
  }

  oprot->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_wred_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_wred_profile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_wred_profile", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
  }

  switch_sai_rpc_sai_thrift_remove_wred_profile_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_wred_profile_result result;
  try {
    result.success = iface_->sai_thrift_remove_wred_profile(args.wred_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile");
  }

  oprot->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_wred_profile", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel(args.thrift_tunnel_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_tunnel_term_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
  }

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_create_tunnel_term_table_entry(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_tunnel_term_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_tunnel_term_table_entry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_result result;
  try {
    result.success = iface_->sai_thrift_remove_tunnel_term_table_entry(args.thrift_tunnel_entry_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry");
  }

  oprot->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_tunnel_term_table_entry", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_qos_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_qos_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_qos_map");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
  }

  switch_sai_rpc_sai_thrift_create_qos_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_qos_map", bytes);
  }

  switch_sai_rpc_sai_thrift_create_qos_map_result result;
  try {
    result.success = iface_->sai_thrift_create_qos_map(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_qos_map");
  }

  oprot->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_qos_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_qos_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_qos_map", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
  }

  switch_sai_rpc_sai_thrift_remove_qos_map_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_qos_map_result result;
  try {
    result.success = iface_->sai_thrift_remove_qos_map(args.qos_map_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map");
  }

  oprot->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_qos_map", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_create_debug_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_create_debug_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
  }

  switch_sai_rpc_sai_thrift_create_debug_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_create_debug_counter_result result;
  try {
    result.success = iface_->sai_thrift_create_debug_counter(args.thrift_attr_list);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter");
  }

  oprot->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_create_debug_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_remove_debug_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_remove_debug_counter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
  }

  switch_sai_rpc_sai_thrift_remove_debug_counter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter", bytes);
  }

  switch_sai_rpc_sai_thrift_remove_debug_counter_result result;
  try {
    result.success = iface_->sai_thrift_remove_debug_counter(args.thrift_debug_counter_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter");
  }

  oprot->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_remove_debug_counter", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_set_debug_counter_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_set_debug_counter_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
  }

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_result result;
  try {
    result.success = iface_->sai_thrift_set_debug_counter_attribute(args.dc_id, args.thrift_attr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_set_debug_counter_attribute", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_sys_port_obj_id_by_port_id(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id");
  }

  switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id", bytes);
  }

  switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_result result;
  try {
    result.success = iface_->sai_thrift_get_sys_port_obj_id_by_port_id(args.sys_port_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_sys_port_obj_id_by_port_id", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id");
  }

  oprot->writeMessageBegin("sai_thrift_get_sys_port_obj_id_by_port_id", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_sys_port_obj_id_by_port_id", bytes);
  }
}

void switch_sai_rpcProcessor::process_sai_thrift_get_system_port_attribute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("switch_sai_rpc.sai_thrift_get_system_port_attribute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute");
  }

  switch_sai_rpc_sai_thrift_get_system_port_attribute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute", bytes);
  }

  switch_sai_rpc_sai_thrift_get_system_port_attribute_result result;
  try {
    iface_->sai_thrift_get_system_port_attribute(result.success, args.sys_port_object_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sai_thrift_get_system_port_attribute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute");
  }

  oprot->writeMessageBegin("sai_thrift_get_system_port_attribute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "switch_sai_rpc.sai_thrift_get_system_port_attribute", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > switch_sai_rpcProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< switch_sai_rpcIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< switch_sai_rpcIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new switch_sai_rpcProcessor(handler));
  return processor;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_port_attribute(port_id, thrift_attr);
  return recv_sai_thrift_set_port_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_port_attribute_pargs args;
  args.port_id = &port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_port_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_get_port_attribute(port_id);
  recv_sai_thrift_get_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_attribute(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_attribute_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_port_stats(port_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_port_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_stats(const sai_thrift_object_id_t port_id, const std::vector<sai_thrift_port_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_stats_pargs args;
  args.port_id = &port_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_clear_port_all_stats(port_id);
  return recv_sai_thrift_clear_port_all_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_port_all_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_port_all_stats_pargs args;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_port_all_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_port_all_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_port_all_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_port_all_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_fdb_entry(thrift_fdb_entry, thrift_attr_list);
  return recv_sai_thrift_create_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t seqid = send_sai_thrift_delete_fdb_entry(thrift_fdb_entry);
  return recv_sai_thrift_delete_fdb_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_delete_fdb_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_delete_fdb_entry_pargs args;
  args.thrift_fdb_entry = &thrift_fdb_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_delete_fdb_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_delete_fdb_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_delete_fdb_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_delete_fdb_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_flush_fdb_entries(thrift_attr_list);
  return recv_sai_thrift_flush_fdb_entries(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_flush_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_flush_fdb_entries_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_flush_fdb_entries(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_flush_fdb_entries") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_flush_fdb_entries_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_flush_fdb_entries failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_fdb_entries(sai_thrift_attribute_list_t& _return)
{
  int32_t seqid = send_sai_thrift_get_fdb_entries();
  recv_sai_thrift_get_fdb_entries(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_fdb_entries()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_fdb_entries", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_fdb_entries_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_fdb_entries(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_fdb_entries") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_fdb_entries_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_fdb_entries failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_vlan(thrift_attr_list);
  return recv_sai_thrift_create_vlan(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_vlan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_vlan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_vlan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t seqid = send_sai_thrift_remove_vlan(vlan_oid);
  return recv_sai_thrift_remove_vlan(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_vlan", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_pargs args;
  args.vlan_oid = &vlan_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_vlan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_vlan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_vlan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const sai_thrift_vlan_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_vlan_stats(vlan_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_vlan_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_stats(const sai_thrift_vlan_id_t vlan_id, const std::vector<sai_thrift_vlan_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_stats_pargs args;
  args.vlan_id = &vlan_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_vlan_member(thrift_attr_list);
  return recv_sai_thrift_create_vlan_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_vlan_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_vlan_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_vlan_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_vlan_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_vlan_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_member_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_member_attribute(vlan_member_id);
  recv_sai_thrift_get_vlan_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_member_attribute_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t seqid = send_sai_thrift_remove_vlan_member(vlan_member_id);
  return recv_sai_thrift_remove_vlan_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_vlan_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_vlan_member_pargs args;
  args.vlan_member_id = &vlan_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_vlan_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_vlan_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_vlan_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_vlan_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t vlan_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_attribute(vlan_id);
  recv_sai_thrift_get_vlan_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_attribute(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_attribute_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const sai_thrift_object_id_t vlan_id)
{
  int32_t seqid = send_sai_thrift_get_vlan_id(vlan_id);
  recv_sai_thrift_get_vlan_id(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_vlan_id(const sai_thrift_object_id_t vlan_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_vlan_id_pargs args;
  args.vlan_id = &vlan_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_vlan_id(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_vlan_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_vlan_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_vlan_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_vlan_attribute(vlan_oid, thrift_attr);
  return recv_sai_thrift_set_vlan_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_vlan_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_vlan_attribute_pargs args;
  args.vlan_oid = &vlan_oid;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_vlan_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_vlan_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_vlan_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_vlan_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_virtual_router(thrift_attr_list);
  return recv_sai_thrift_create_virtual_router(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_virtual_router_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_virtual_router(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_virtual_router") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_virtual_router_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_virtual_router failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t seqid = send_sai_thrift_remove_virtual_router(vr_id);
  return recv_sai_thrift_remove_virtual_router(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_virtual_router", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_virtual_router_pargs args;
  args.vr_id = &vr_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_virtual_router(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_virtual_router") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_virtual_router_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_virtual_router failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_route(thrift_route_entry, thrift_attr_list);
  return recv_sai_thrift_create_route(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_route(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_route") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_route_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_route failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t seqid = send_sai_thrift_remove_route(thrift_route_entry);
  return recv_sai_thrift_remove_route(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_route", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_route_pargs args;
  args.thrift_route_entry = &thrift_route_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_route(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_route") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_route_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_route failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_router_interface(thrift_attr_list);
  return recv_sai_thrift_create_router_interface(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_router_interface_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_router_interface(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_router_interface") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_router_interface_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_router_interface failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t seqid = send_sai_thrift_remove_router_interface(rif_id);
  return recv_sai_thrift_remove_router_interface(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_router_interface", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_router_interface_pargs args;
  args.rif_id = &rif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_router_interface(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_router_interface") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_router_interface_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_router_interface failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_router_interface_attribute(rif_id, thrift_attr);
  return recv_sai_thrift_set_router_interface_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t rif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_router_interface_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_router_interface_attribute_pargs args;
  args.rif_id = &rif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_router_interface_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_router_interface_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_router_interface_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_router_interface_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop(thrift_attr_list);
  return recv_sai_thrift_create_next_hop(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t seqid = send_sai_thrift_remove_next_hop(next_hop_id);
  return recv_sai_thrift_remove_next_hop(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_pargs args;
  args.next_hop_id = &next_hop_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop_group(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t seqid = send_sai_thrift_remove_next_hop_group(nhop_group_oid);
  return recv_sai_thrift_remove_next_hop_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t nhop_group_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_pargs args;
  args.nhop_group_oid = &nhop_group_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_next_hop_group_member(thrift_attr_list);
  return recv_sai_thrift_create_next_hop_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_next_hop_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_next_hop_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_next_hop_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_next_hop_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_next_hop_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t seqid = send_sai_thrift_remove_next_hop_group_member(nhop_group_member_oid);
  return recv_sai_thrift_remove_next_hop_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t nhop_group_member_oid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_next_hop_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_next_hop_group_member_pargs args;
  args.nhop_group_member_oid = &nhop_group_member_oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_next_hop_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_next_hop_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_next_hop_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_next_hop_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_lag(thrift_attr_list);
  return recv_sai_thrift_create_lag(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_lag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_lag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_lag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t seqid = send_sai_thrift_remove_lag(lag_id);
  return recv_sai_thrift_remove_lag(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_lag", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_pargs args;
  args.lag_id = &lag_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_lag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_lag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_lag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_lag_attribute(lag_id, thrift_attr);
  return recv_sai_thrift_set_lag_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_lag_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_lag_attribute_pargs args;
  args.lag_id = &lag_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_lag_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_lag_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_lag_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_lag_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_lag_member(thrift_attr_list);
  return recv_sai_thrift_create_lag_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_lag_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_lag_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_lag_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_lag_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_lag_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t seqid = send_sai_thrift_remove_lag_member(lag_member_id);
  return recv_sai_thrift_remove_lag_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_lag_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_lag_member_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_lag_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_lag_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_lag_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_lag_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t lag_member_id)
{
  int32_t seqid = send_sai_thrift_get_lag_member_attribute(lag_member_id);
  recv_sai_thrift_get_lag_member_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_lag_member_attribute(const sai_thrift_object_id_t lag_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_lag_member_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_lag_member_attribute_pargs args;
  args.lag_member_id = &lag_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_lag_member_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_lag_member_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_lag_member_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_stp_entry(thrift_attr_list);
  return recv_sai_thrift_create_stp_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_stp_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_stp_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_stp_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_stp_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_stp_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_stp_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t seqid = send_sai_thrift_remove_stp_entry(stp_id);
  return recv_sai_thrift_remove_stp_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_stp_entry(const sai_thrift_object_id_t stp_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_stp_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_stp_entry_pargs args;
  args.stp_id = &stp_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_stp_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_stp_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_stp_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_stp_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t seqid = send_sai_thrift_set_stp_port_state(stp_id, port_id, stp_port_state);
  return recv_sai_thrift_set_stp_port_state(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.stp_port_state = &stp_port_state;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_stp_port_state(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_stp_port_state") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_stp_port_state_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_stp_port_state failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_port_stp_port_state_t switch_sai_rpcConcurrentClient::sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t seqid = send_sai_thrift_get_stp_port_state(stp_id, port_id);
  return recv_sai_thrift_get_stp_port_state(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_stp_port_state(const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_stp_port_state", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_stp_port_state_pargs args;
  args.stp_id = &stp_id;
  args.port_id = &port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_port_stp_port_state_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_stp_port_state(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_stp_port_state") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_port_stp_port_state_t _return;
      switch_sai_rpc_sai_thrift_get_stp_port_state_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_stp_port_state failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_neighbor_entry(thrift_neighbor_entry, thrift_attr_list);
  return recv_sai_thrift_create_neighbor_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_neighbor_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_neighbor_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_create_neighbor_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_neighbor_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t seqid = send_sai_thrift_remove_neighbor_entry(thrift_neighbor_entry);
  return recv_sai_thrift_remove_neighbor_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_neighbor_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_neighbor_entry_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_neighbor_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_neighbor_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_neighbor_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_neighbor_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_neighbor_entry_attribute(thrift_neighbor_entry, thrift_attr);
  return recv_sai_thrift_set_neighbor_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_neighbor_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_pargs args;
  args.thrift_neighbor_entry = &thrift_neighbor_entry;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_neighbor_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_neighbor_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_neighbor_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_neighbor_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return)
{
  int32_t seqid = send_sai_thrift_get_switch_attribute();
  recv_sai_thrift_get_switch_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_switch_attribute()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_attribute_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_switch_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_switch_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return)
{
  int32_t seqid = send_sai_thrift_get_port_list_by_front_port();
  recv_sai_thrift_get_port_list_by_front_port(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_list_by_front_port()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_list_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_list_by_front_port_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_list_by_front_port(sai_thrift_attribute_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_list_by_front_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_port_list_by_front_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_list_by_front_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_cpu_port_id()
{
  int32_t seqid = send_sai_thrift_get_cpu_port_id();
  return recv_sai_thrift_get_cpu_port_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_cpu_port_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_cpu_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_cpu_port_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_cpu_port_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_cpu_port_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_cpu_port_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_cpu_port_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_trap_group()
{
  int32_t seqid = send_sai_thrift_get_default_trap_group();
  return recv_sai_thrift_get_default_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_trap_group()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_trap_group_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_router_id()
{
  int32_t seqid = send_sai_thrift_get_default_router_id();
  return recv_sai_thrift_get_default_router_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_router_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_router_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_router_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_router_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_router_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_router_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_router_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_default_1q_bridge_id()
{
  int32_t seqid = send_sai_thrift_get_default_1q_bridge_id();
  return recv_sai_thrift_get_default_1q_bridge_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_1q_bridge_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_1q_bridge_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_1q_bridge_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_1q_bridge_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_default_1q_bridge_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_1q_bridge_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return)
{
  int32_t seqid = send_sai_thrift_get_default_vlan_id();
  recv_sai_thrift_get_default_vlan_id(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_default_vlan_id()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_default_vlan_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_default_vlan_id_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_default_vlan_id(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_default_vlan_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_default_vlan_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_default_vlan_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t seqid = send_sai_thrift_get_port_id_by_front_port(port_name);
  return recv_sai_thrift_get_port_id_by_front_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_port_id_by_front_port(const std::string& port_name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_port_id_by_front_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_port_id_by_front_port_pargs args;
  args.port_name = &port_name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_port_id_by_front_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_port_id_by_front_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_port_id_by_front_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_port_id_by_front_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t seqid = send_sai_thrift_set_switch_attribute(attribute);
  return recv_sai_thrift_set_switch_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attribute)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_switch_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_switch_attribute_pargs args;
  args.attribute = &attribute;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_switch_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_switch_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_switch_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_switch_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int64_t switch_sai_rpcConcurrentClient::sai_thrift_get_switch_stats_by_oid(const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t seqid = send_sai_thrift_get_switch_stats_by_oid(thrift_counter_id);
  return recv_sai_thrift_get_switch_stats_by_oid(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_switch_stats_by_oid(const sai_thrift_object_id_t thrift_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_switch_stats_by_oid", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_pargs args;
  args.thrift_counter_id = &thrift_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_switch_stats_by_oid(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_switch_stats_by_oid") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      switch_sai_rpc_sai_thrift_get_switch_stats_by_oid_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_switch_stats_by_oid failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_bridge_port(thrift_attr_list);
  recv_sai_thrift_create_bridge_port(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_port_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_bridge_port(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_bridge_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_bridge_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t seqid = send_sai_thrift_remove_bridge_port(bridge_port_id);
  return recv_sai_thrift_remove_bridge_port(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_bridge_port", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_port_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_bridge_port(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_bridge_port") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_bridge_port_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge_port failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const sai_thrift_object_id_t bridge_id)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_list(bridge_id);
  recv_sai_thrift_get_bridge_port_list(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_list(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_list", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_list_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_list(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_list") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_list_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_list failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t bridge_port_id)
{
  int32_t seqid = send_sai_thrift_get_bridge_port_attribute(bridge_port_id);
  recv_sai_thrift_get_bridge_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_bridge_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_bridge_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_bridge_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_bridge_port_attribute(bridge_port_id, thrift_attr);
  return recv_sai_thrift_set_bridge_port_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_bridge_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_bridge_port_attribute_pargs args;
  args.bridge_port_id = &bridge_port_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_bridge_port_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_bridge_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_bridge_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_bridge_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_create_bridge(sai_thrift_result_t& _return, const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_bridge(thrift_attr_list);
  recv_sai_thrift_create_bridge(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_bridge_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_create_bridge(sai_thrift_result_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_bridge") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_create_bridge_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_bridge failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t seqid = send_sai_thrift_remove_bridge(bridge_id);
  return recv_sai_thrift_remove_bridge(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_bridge", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_bridge_pargs args;
  args.bridge_id = &bridge_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_bridge(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_bridge") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_bridge_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_bridge failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif(thrift_attr_list);
  return recv_sai_thrift_create_hostif(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif(thrift_hif_id);
  return recv_sai_thrift_remove_hostif(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif(const sai_thrift_object_id_t thrift_hif_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_attribute(thrift_hif_id, thrift_attr);
  return recv_sai_thrift_set_hostif_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t thrift_hif_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_attribute_pargs args;
  args.thrift_hif_id = &thrift_hif_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_hostif_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hif_table_entry_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_table_entry(thrift_hif_table_entry_id);
  return recv_sai_thrift_remove_hostif_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t thrift_hif_table_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_table_entry_pargs args;
  args.thrift_hif_table_entry_id = &thrift_hif_table_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_table_entry_attribute(thrift_hif_table_entry_id, thrift_attr);
  return recv_sai_thrift_set_hostif_table_entry_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t thrift_hif_table_entry_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_table_entry_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_pargs args;
  args.thrift_hif_table_entry_id = &thrift_hif_table_entry_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_table_entry_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_table_entry_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_table_entry_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_table_entry_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_trap_group(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_trap_group(thrift_hostif_trap_group_id);
  return recv_sai_thrift_remove_hostif_trap_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t thrift_hostif_trap_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_group_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_trap_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_trap_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_trap_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_trap_group_attribute(thrift_hostif_trap_group_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t thrift_hostif_trap_group_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_pargs args;
  args.thrift_hostif_trap_group_id = &thrift_hostif_trap_group_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_trap_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_trap_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_trap_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_hostif_trap(thrift_attr_list);
  return recv_sai_thrift_create_hostif_trap(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_hostif_trap_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_hostif_trap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_hostif_trap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_hostif_trap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_hostif_trap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t seqid = send_sai_thrift_remove_hostif_trap(thrift_hostif_trap_id);
  return recv_sai_thrift_remove_hostif_trap(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t thrift_hostif_trap_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_hostif_trap", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_hostif_trap_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_hostif_trap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_hostif_trap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_hostif_trap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_hostif_trap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_hostif_trap_attribute(thrift_hostif_trap_id, thrift_attr);
  return recv_sai_thrift_set_hostif_trap_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t thrift_hostif_trap_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_hostif_trap_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_pargs args;
  args.thrift_hostif_trap_id = &thrift_hostif_trap_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_hostif_trap_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_hostif_trap_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_hostif_trap_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_hostif_trap_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table(thrift_attr_list);
  return recv_sai_thrift_create_acl_table(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table(acl_table_id);
  return recv_sai_thrift_remove_acl_table(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_pargs args;
  args.acl_table_id = &acl_table_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_entry(thrift_attr_list);
  return recv_sai_thrift_create_acl_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t seqid = send_sai_thrift_remove_acl_entry(acl_entry);
  return recv_sai_thrift_remove_acl_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_entry_pargs args;
  args.acl_entry = &acl_entry;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table_group(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table_group(acl_table_group_id);
  return recv_sai_thrift_remove_acl_table_group(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_pargs args;
  args.acl_table_group_id = &acl_table_group_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table_group(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table_group") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_group_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_table_group_member(thrift_attr_list);
  return recv_sai_thrift_create_acl_table_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_table_group_member_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_table_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_table_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_table_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_table_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_table_group_member(acl_table_group_member_id);
  return recv_sai_thrift_remove_acl_table_group_member(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_table_group_member", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_table_group_member_pargs args;
  args.acl_table_group_member_id = &acl_table_group_member_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_table_group_member(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_table_group_member") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_table_group_member_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_table_group_member failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_acl_counter(thrift_attr_list);
  return recv_sai_thrift_create_acl_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_acl_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_acl_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_acl_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_acl_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_acl_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t seqid = send_sai_thrift_remove_acl_counter(acl_counter_id);
  return recv_sai_thrift_remove_acl_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_acl_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_acl_counter_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_acl_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_acl_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_acl_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_acl_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t seqid = send_sai_thrift_get_acl_counter_attribute(acl_counter_id, thrift_attr_ids);
  recv_sai_thrift_get_acl_counter_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_id, const std::vector<int32_t> & thrift_attr_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_acl_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_acl_counter_attribute_pargs args;
  args.acl_counter_id = &acl_counter_id;
  args.thrift_attr_ids = &thrift_attr_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_acl_counter_attribute(std::vector<sai_thrift_attribute_value_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_acl_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_acl_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_acl_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_mirror_session(thrift_attr_list);
  return recv_sai_thrift_create_mirror_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_mirror_session_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_mirror_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_mirror_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_mirror_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_mirror_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t seqid = send_sai_thrift_remove_mirror_session(session_id);
  return recv_sai_thrift_remove_mirror_session(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_mirror_session", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_mirror_session_pargs args;
  args.session_id = &session_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_mirror_session(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_mirror_session") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_mirror_session_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_mirror_session failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_mirror_session_attribute(session_id, thrift_attr);
  return recv_sai_thrift_set_mirror_session_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t session_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_mirror_session_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_mirror_session_attribute_pargs args;
  args.session_id = &session_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_mirror_session_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_mirror_session_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_mirror_session_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_mirror_session_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_policer(thrift_attr_list);
  return recv_sai_thrift_create_policer(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_policer_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_policer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_policer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_policer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_policer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t seqid = send_sai_thrift_remove_policer(thrift_policer_id);
  return recv_sai_thrift_remove_policer(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_policer(const sai_thrift_object_id_t thrift_policer_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_policer", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_policer_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_policer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_policer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_policer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_policer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_policer_attribute(thrift_policer_id, thrift_attr);
  return recv_sai_thrift_set_policer_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_policer_attribute(const sai_thrift_object_id_t thrift_policer_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_policer_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_policer_attribute_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_policer_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_policer_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_policer_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_policer_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t seqid = send_sai_thrift_get_policer_stats(thrift_policer_id, thrift_counter_ids);
  recv_sai_thrift_get_policer_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_policer_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_policer_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_policer_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t seqid = send_sai_thrift_clear_policer_stats(thrift_policer_id, thrift_counter_ids);
  return recv_sai_thrift_clear_policer_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_policer_stats(const sai_thrift_object_id_t thrift_policer_id, const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_policer_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_policer_stats_pargs args;
  args.thrift_policer_id = &thrift_policer_id;
  args.thrift_counter_ids = &thrift_counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_policer_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_policer_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_policer_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_policer_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_scheduler_profile(thrift_attr_list);
  return recv_sai_thrift_create_scheduler_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_scheduler_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_scheduler_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_scheduler_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_scheduler_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_scheduler_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_scheduler_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t seqid = send_sai_thrift_remove_scheduler_profile(scheduler_id);
  return recv_sai_thrift_remove_scheduler_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_scheduler_profile(const sai_thrift_object_id_t scheduler_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_scheduler_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_scheduler_profile_pargs args;
  args.scheduler_id = &scheduler_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_scheduler_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_scheduler_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_scheduler_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_scheduler_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_queue_stats(queue_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_queue_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_queue_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_queue_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_queue_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_queue_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_clear_queue_stats(queue_id, counter_ids, number_of_counters);
  return recv_sai_thrift_clear_queue_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_id, const std::vector<sai_thrift_queue_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_queue_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_queue_stats_pargs args;
  args.queue_id = &queue_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_queue_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_queue_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_queue_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_queue_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_queue_attribute(queue_id, thrift_attr);
  return recv_sai_thrift_set_queue_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_queue_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_queue_attribute_pargs args;
  args.queue_id = &queue_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_queue_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_queue_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_queue_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_queue_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_buffer_profile(thrift_attr_list);
  return recv_sai_thrift_create_buffer_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_buffer_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_buffer_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_buffer_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_buffer_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_buffer_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_buffer_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_pool_profile(thrift_attr_list);
  return recv_sai_thrift_create_pool_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_pool_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_pool_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_pool_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_pool_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_pool_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_pool_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_pool_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_buffer_pool_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t seqid = send_sai_thrift_get_buffer_pool_stats(buffer_pool_id, counter_ids);
  recv_sai_thrift_get_buffer_pool_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_buffer_pool_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_buffer_pool_stats_pargs args;
  args.buffer_pool_id = &buffer_pool_id;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_buffer_pool_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_buffer_pool_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_buffer_pool_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_buffer_pool_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t seqid = send_sai_thrift_clear_buffer_pool_stats(buffer_pool_id, counter_ids);
  return recv_sai_thrift_clear_buffer_pool_stats(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_id, const std::vector<sai_thrift_buffer_pool_stat_counter_t> & counter_ids)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_clear_buffer_pool_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_pargs args;
  args.buffer_pool_id = &buffer_pool_id;
  args.counter_ids = &counter_ids;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_clear_buffer_pool_stats(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_clear_buffer_pool_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_clear_buffer_pool_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_clear_buffer_pool_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_priority_group_attribute(pg_id, thrift_attr);
  return recv_sai_thrift_set_priority_group_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_priority_group_attribute(const sai_thrift_object_id_t pg_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_priority_group_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_priority_group_attribute_pargs args;
  args.pg_id = &pg_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_priority_group_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_priority_group_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_priority_group_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_priority_group_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t seqid = send_sai_thrift_get_pg_stats(pg_id, counter_ids, number_of_counters);
  recv_sai_thrift_get_pg_stats(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_pg_stats(const sai_thrift_object_id_t pg_id, const std::vector<sai_thrift_pg_stat_counter_t> & counter_ids, const int32_t number_of_counters)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_pg_stats", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_pg_stats_pargs args;
  args.pg_id = &pg_id;
  args.counter_ids = &counter_ids;
  args.number_of_counters = &number_of_counters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_pg_stats(std::vector<int64_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_pg_stats") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_pg_stats_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_pg_stats failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_wred_profile(thrift_attr_list);
  return recv_sai_thrift_create_wred_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_wred_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_wred_profile_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_wred_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_wred_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_wred_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_wred_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t seqid = send_sai_thrift_remove_wred_profile(wred_id);
  return recv_sai_thrift_remove_wred_profile(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_wred_profile(const sai_thrift_object_id_t wred_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_wred_profile", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_wred_profile_pargs args;
  args.wred_id = &wred_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_wred_profile(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_wred_profile") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_wred_profile_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_wred_profile failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel(thrift_attr_list);
  return recv_sai_thrift_create_tunnel(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel(const sai_thrift_object_id_t thrift_tunnel_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel(thrift_tunnel_id);
  return recv_sai_thrift_remove_tunnel(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel(const sai_thrift_object_id_t thrift_tunnel_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_pargs args;
  args.thrift_tunnel_id = &thrift_tunnel_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_tunnel_term_table_entry(thrift_attr_list);
  return recv_sai_thrift_create_tunnel_term_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_tunnel_term_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_tunnel_term_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_tunnel_term_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_tunnel_term_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t thrift_tunnel_entry_id)
{
  int32_t seqid = send_sai_thrift_remove_tunnel_term_table_entry(thrift_tunnel_entry_id);
  return recv_sai_thrift_remove_tunnel_term_table_entry(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t thrift_tunnel_entry_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_tunnel_term_table_entry", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_pargs args;
  args.thrift_tunnel_entry_id = &thrift_tunnel_entry_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_tunnel_term_table_entry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_tunnel_term_table_entry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_tunnel_term_table_entry_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_tunnel_term_table_entry failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_qos_map(thrift_attr_list);
  return recv_sai_thrift_create_qos_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_qos_map_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_qos_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_qos_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_qos_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_qos_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t seqid = send_sai_thrift_remove_qos_map(qos_map_id);
  return recv_sai_thrift_remove_qos_map(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_qos_map", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_qos_map_pargs args;
  args.qos_map_id = &qos_map_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_qos_map(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_qos_map") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_qos_map_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_qos_map failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t seqid = send_sai_thrift_create_debug_counter(thrift_attr_list);
  return recv_sai_thrift_create_debug_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_create_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_create_debug_counter_pargs args;
  args.thrift_attr_list = &thrift_attr_list;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_create_debug_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_create_debug_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_create_debug_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_create_debug_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_remove_debug_counter(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t seqid = send_sai_thrift_remove_debug_counter(thrift_debug_counter_id);
  return recv_sai_thrift_remove_debug_counter(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_remove_debug_counter(const sai_thrift_object_id_t thrift_debug_counter_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_remove_debug_counter", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_remove_debug_counter_pargs args;
  args.thrift_debug_counter_id = &thrift_debug_counter_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_remove_debug_counter(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_remove_debug_counter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_remove_debug_counter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_remove_debug_counter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t dc_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t seqid = send_sai_thrift_set_debug_counter_attribute(dc_id, thrift_attr);
  return recv_sai_thrift_set_debug_counter_attribute(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t dc_id, const sai_thrift_attribute_t& thrift_attr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_set_debug_counter_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_set_debug_counter_attribute_pargs args;
  args.dc_id = &dc_id;
  args.thrift_attr = &thrift_attr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_status_t switch_sai_rpcConcurrentClient::recv_sai_thrift_set_debug_counter_attribute(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_set_debug_counter_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_status_t _return;
      switch_sai_rpc_sai_thrift_set_debug_counter_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_set_debug_counter_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::sai_thrift_get_sys_port_obj_id_by_port_id(const int32_t sys_port_id)
{
  int32_t seqid = send_sai_thrift_get_sys_port_obj_id_by_port_id(sys_port_id);
  return recv_sai_thrift_get_sys_port_obj_id_by_port_id(seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_sys_port_obj_id_by_port_id(const int32_t sys_port_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_sys_port_obj_id_by_port_id", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_pargs args;
  args.sys_port_id = &sys_port_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

sai_thrift_object_id_t switch_sai_rpcConcurrentClient::recv_sai_thrift_get_sys_port_obj_id_by_port_id(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_sys_port_obj_id_by_port_id") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      sai_thrift_object_id_t _return;
      switch_sai_rpc_sai_thrift_get_sys_port_obj_id_by_port_id_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_sys_port_obj_id_by_port_id failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void switch_sai_rpcConcurrentClient::sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& _return, const sai_thrift_object_id_t sys_port_object_id)
{
  int32_t seqid = send_sai_thrift_get_system_port_attribute(sys_port_object_id);
  recv_sai_thrift_get_system_port_attribute(_return, seqid);
}

int32_t switch_sai_rpcConcurrentClient::send_sai_thrift_get_system_port_attribute(const sai_thrift_object_id_t sys_port_object_id)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("sai_thrift_get_system_port_attribute", ::apache::thrift::protocol::T_CALL, cseqid);

  switch_sai_rpc_sai_thrift_get_system_port_attribute_pargs args;
  args.sys_port_object_id = &sys_port_object_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void switch_sai_rpcConcurrentClient::recv_sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("sai_thrift_get_system_port_attribute") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      switch_sai_rpc_sai_thrift_get_system_port_attribute_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sai_thrift_get_system_port_attribute failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

